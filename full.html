<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>Matem&aacute;tica</title>
        <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}
:root{
    --vscode-activityBar-activeBorder: #0078d4;
    --vscode-activityBar-background: #181818;
    --vscode-activityBar-border: #ffffff15;
    --vscode-activityBar-foreground: #d7d7d7;
    --vscode-activityBar-inactiveForeground: #ffffff80;
    --vscode-activityBarBadge-background: #0078d4;
    --vscode-activityBarBadge-foreground: #ffffff;
    --vscode-badge-background: #0078d4;
    --vscode-badge-foreground: #ffffff;
    --vscode-button-background: #0078d4;
    --vscode-button-border: #ffffff12;
    --vscode-button-foreground: #ffffff;
    --vscode-button-hoverBackground: #0078d4e6;
    --vscode-button-secondaryBackground: #ffffff0f;
    --vscode-button-secondaryForeground: #cccccc;
    --vscode-button-secondaryHoverBackground: #ffffff15;
    --vscode-checkbox-background: #313131;
    --vscode-checkbox-border: #ffffff1f;
    --vscode-debugToolBar-background: #181818;
    --vscode-descriptionForeground: #8b949e;
    --vscode-dropdown-background: #313131;
    --vscode-dropdown-border: #ffffff1f;
    --vscode-dropdown-foreground: #cccccc;
    --vscode-dropdown-listBackground: #1f1f1f;
    --vscode-editor-background: #1f1f1f;
    --vscode-editor-findMatchBackground: #9e6a03;
    --vscode-editor-foreground: #cccccc;
    --vscode-editor-inactiveSelectionBackground: #3a3d41;
    --vscode-editor-selectionHighlightBackground: #add6ff26;
    --vscode-editorGroup-border: #ffffff17;
    --vscode-editorGroupHeader-tabsBackground: #181818;
    --vscode-editorGroupHeader-tabsBorder: #ffffff15;
    --vscode-editorGutter-addedBackground: #2ea043;
    --vscode-editorGutter-deletedBackground: #f85149;
    --vscode-editorGutter-modifiedBackground: #0078d4;
    --vscode-editorIndentGuide-activeBackground: #707070;
    --vscode-editorIndentGuide-background: #404040;
    --vscode-editorInlayHint-background: #8b949e1b;
    --vscode-editorInlayHint-typeBackground: #8b949e1b;
    --vscode-editorLineNumber-activeForeground: #cccccc;
    --vscode-editorLineNumber-foreground: #6e7681;
    --vscode-editorOverviewRuler-border: #010409;
    --vscode-editorWidget-background: #1f1f1f;
    --vscode-errorForeground: #f85149;
    --vscode-focusBorder: #0078d4;
    --vscode-foreground: #cccccc;
    --vscode-icon-foreground: #cccccc;
    --vscode-input-background: #2a2a2a;
    --vscode-input-border: #ffffff1f;
    --vscode-input-foreground: #cccccc;
    --vscode-input-placeholderForeground: #ffffff79;
    --vscode-inputOption-activeBackground: #2489db82;
    --vscode-inputOption-activeBorder: #2488db;
    --vscode-keybindingLabel-foreground: #cccccc;
    --vscode-list-activeSelectionBackground: #323232;
    --vscode-list-activeSelectionForeground: #ffffff;
    --vscode-list-activeSelectionIconForeground: #ffffff;
    --vscode-list-dropBackground: #383b3d;
    --vscode-menu-background: #1f1f1f;
    --vscode-menu-border: #454545;
    --vscode-menu-foreground: #cccccc;
    --vscode-menu-separatorBackground: #454545;
    --vscode-notificationCenterHeader-background: #1f1f1f;
    --vscode-notificationCenterHeader-foreground: #cccccc;
    --vscode-notifications-background: #1f1f1f;
    --vscode-notifications-border: #ffffff15;
    --vscode-notifications-foreground: #cccccc;
    --vscode-panel-background: #181818;
    --vscode-panel-border: #ffffff15;
    --vscode-panelInput-border: #ffffff15;
    --vscode-panelTitle-activeBorder: #0078d4;
    --vscode-panelTitle-activeForeground: #cccccc;
    --vscode-panelTitle-inactiveForeground: #8b949e;
    --vscode-peekViewEditor-background: #1f1f1f;
    --vscode-peekViewEditor-matchHighlightBackground: #bb800966;
    --vscode-peekViewResult-background: #1f1f1f;
    --vscode-peekViewResult-matchHighlightBackground: #bb800966;
    --vscode-pickerGroup-border: #ffffff15;
    --vscode-pickerGroup-foreground: #8b949e;
    --vscode-ports-iconRunningProcessForeground: #369432;
    --vscode-progressBar-background: #0078d4;
    --vscode-quickInput-background: #1f1f1f;
    --vscode-quickInput-foreground: #cccccc;
    --vscode-scrollbar-shadow: #484f5833;
    --vscode-scrollbarSlider-activeBackground: #6e768187;
    --vscode-scrollbarSlider-background: #6e768133;
    --vscode-scrollbarSlider-hoverBackground: #6e768145;
    --vscode-settings-dropdownBackground: #313131;
    --vscode-settings-dropdownBorder: #ffffff1f;
    --vscode-settings-headerForeground: #ffffff;
    --vscode-settings-modifiedItemIndicator: #bb800966;
    --vscode-sideBar-background: #181818;
    --vscode-sideBar-border: #ffffff15;
    --vscode-sideBar-foreground: #cccccc;
    --vscode-sideBarSectionHeader-background: #181818;
    --vscode-sideBarSectionHeader-border: #ffffff15;
    --vscode-sideBarSectionHeader-foreground: #cccccc;
    --vscode-sideBarTitle-foreground: #cccccc;
    --vscode-statusBar-background: #181818;
    --vscode-statusBar-border: #ffffff15;
    --vscode-statusBar-debuggingBackground: #0078d4;
    --vscode-statusBar-debuggingForeground: #ffffff;
    --vscode-statusBar-focusBorder: #0078d4;
    --vscode-statusBar-foreground: #cccccc;
    --vscode-statusBar-noFolderBackground: #1f1f1f;
    --vscode-statusBarItem-focusBorder: #0078d4;
    --vscode-statusBarItem-prominentBackground: #6e768166;
    --vscode-statusBarItem-remoteBackground: #0078d4;
    --vscode-statusBarItem-remoteForeground: #ffffff;
    --vscode-tab-activeBackground: #1f1f1f;
    --vscode-tab-activeBorder: #1f1f1f;
    --vscode-tab-activeBorderTop: #0078d4;
    --vscode-tab-activeForeground: #ffffff;
    --vscode-tab-border: #ffffff15;
    --vscode-tab-hoverBackground: #1f1f1f;
    --vscode-tab-inactiveBackground: #181818;
    --vscode-tab-inactiveForeground: #ffffff80;
    --vscode-tab-lastPinnedBorder: #cccccc33;
    --vscode-tab-unfocusedActiveBorder: #1f1f1f;
    --vscode-tab-unfocusedActiveBorderTop: #ffffff15;
    --vscode-tab-unfocusedHoverBackground: #6e76811a;
    --vscode-terminal-foreground: #cccccc;
    --vscode-terminal-inactiveSelectionBackground: #3a3d41;
    --vscode-terminal-tab-activeBorder: #0078d4;
    --vscode-textBlockQuote-background: #010409;
    --vscode-textBlockQuote-border: #ffffff14;
    --vscode-textCodeBlock-background: #7e869166;
    --vscode-textLink-activeForeground: #40a6ff;
    --vscode-textLink-foreground: #40a6ff;
    --vscode-textSeparator-foreground: #21262d;
    --vscode-titleBar-activeBackground: #181818;
    --vscode-titleBar-activeForeground: #cccccc;
    --vscode-titleBar-border: #ffffff15;
    --vscode-titleBar-inactiveBackground: #1f1f1f;
    --vscode-titleBar-inactiveForeground: #8b949e;
    --vscode-welcomePage-progress-foreground: #0078d4;
    --vscode-welcomePage-tileBackground: #ffffff0f;
    --vscode-widget-border: #ffffff15;
}
pre code{
    color: #010409 !important;
}

</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="matemática">Matemática</h1>
<h1 id="fibonacci">Fibonacci</h1>
<p>Na matemática, a sucessão de Fibonacci (ou sequência de Fibonacci), é uma sequência de números inteiros, começando normalmente por 0 e 1, na qual cada termo subsequente corresponde à soma dos dois anteriores.</p>
<p>Definição: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>i</mi><mi>b</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mi>i</mi><mi>b</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mi>i</mi><mi>b</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">fib(n) = fib(n-1) + fib(n-2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">ib</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">ib</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">ib</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>, para <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n \gt 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>.
Note que <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>i</mi><mi>b</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">fib(0) = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">ib</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> e <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>i</mi><mi>b</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">fib(1) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">ib</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></p>
<h2 id="período-de-pisano">Período de Pisano</h2>
<p>A sequência de Fibonacci mod M é sempre periódica. Ou seja, para um M no qual o periodo seja 6, como o Pisano de 4, fibonacci de 0 e o de 6 será o mesmo, e o de 1 e o 7 também, e assim por diante, de forma que a equação abaixo é verdadeira:</p>
<p>Função de Pisano = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi (k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></p>
<p><strong>OBS:</strong> Essa propriedade é muito útil para calcular <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>i</mi><mi>b</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mi>M</mi></mrow><annotation encoding="application/x-tex">fib(n) \bmod M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">ib</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> quando n for um número muito grande, pois:</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mi>i</mi><mi>b</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mi>M</mi><mo>=</mo><mi>f</mi><mi>i</mi><mi>b</mi><mo stretchy="false">(</mo><mi>n</mi><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mi>π</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mi>M</mi></mrow><annotation encoding="application/x-tex">fib(n) \bmod M = fib(n \bmod \pi (M)) \bmod M
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">ib</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">ib</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span></span></p>
<p><strong>Algoritmo:</strong></p>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">pisano</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> m)</span>
</span>{
    <span class="hljs-type">long</span> <span class="hljs-type">long</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>, c = a + b;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m * m; i++)
    {
        c = (a + b) % m;
        a = b;
        b = c;
        <span class="hljs-keyword">if</span> (a == <span class="hljs-number">0</span> &amp;&amp; b == <span class="hljs-number">1</span>)
            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">return</span> m*m;
}
</code></pre>
<h2 id="exponenciação-de-matriz---ologn">Exponenciação de Matriz - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span>.</h2>
<p>Essa solução é muito pouco conhecida e se baseia na seguinte propriedade:
elevar a matriz { {1,1} , {1, 0} } no expoente n resulta na matriz { {fib(n+1) ,fib(n)} , {fib(n), fib(n-1)} }.</p>
<pre><code class="language-C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mult</span><span class="hljs-params">(ll m[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>], ll m2[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>], ll mod)</span>
</span>{
    ll a = (m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] * m2[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]) % mod + (m[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] * m2[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]) % mod;
    ll b = (m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] * m2[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]) % mod + (m[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] * m2[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) % mod;
    ll c = (m[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] * m2[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]) % mod + (m[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] * m2[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]) % mod;
    ll d = (m[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] * m2[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]) % mod + (m[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] * m2[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) % mod;

    m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = a % mod;
    m[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = b % mod;
    m[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = c % mod;
    m[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = d % mod;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getBit_64</span><span class="hljs-params">(ll n, <span class="hljs-type">int</span> shiftLeft)</span>
</span>{
    ll mask = (ll)<span class="hljs-number">1</span> &lt;&lt; shiftLeft;

    <span class="hljs-keyword">if</span>((n &amp; mask) != <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">msb_64</span><span class="hljs-params">(ll n)</span>
</span>{
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">63</span>; i &gt;= <span class="hljs-number">0</span>; i--)
    {
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">getBit_64</span>(n, i) == <span class="hljs-number">1</span>)
            <span class="hljs-keyword">return</span> i;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}
<span class="hljs-function">ll <span class="hljs-title">fibRapido</span><span class="hljs-params">(ll n, ll mod)</span>
</span>{
    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-type">int</span> msbN = <span class="hljs-built_in">msb_64</span>(n);

    ll resp[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = {{<span class="hljs-number">1</span>,<span class="hljs-number">0</span>},{<span class="hljs-number">0</span>,<span class="hljs-number">1</span>}}; <span class="hljs-comment">// matriz identidade</span>
    ll fator[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = {{<span class="hljs-number">1</span>,<span class="hljs-number">1</span>},{<span class="hljs-number">1</span>,<span class="hljs-number">0</span>}};

    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= msbN; i++)
    {
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">getBit_64</span>(n, i) == <span class="hljs-number">1</span>)
        {
            <span class="hljs-built_in">mult</span>(resp, fator, mod);
        }

        <span class="hljs-built_in">mult</span>(fator, fator, mod);
    }

    <span class="hljs-keyword">return</span> resp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];
}
</code></pre>
<p>O algoritmo apresentado retorna a resposta mod m, pois ele serve para trabalhar com números muito grandes, os quais resultam em overflow se não houver operação de módulo envolvida. Ex: fib(1.000.000.000) mod 100. É importante notar que apesar de ele ser muito mais rápido que o algoritmo anterior, ele deve ser utilizado somente quando for imprescindível, posto que demanda muito mais código.</p>
<h2 id="algoritmo-de-fibonacci-fast-doubling">Algoritmo de Fibonacci Fast Doubling</h2>
<p>É a versão simplificada do algoritmo de multiplicação de matriz, evitando contas desnecessárias.</p>
<p>O método Fast Doubling  é baseado nas seguintes duas formulas:</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>F</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">[</mo><mn>2</mn><mi>F</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mtext>–</mtext><mi>F</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">F(2n) = F(n)[2F(n+1) – F(n)]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mopen">[</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">–</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)]</span></span></span></span></span></p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>F</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mn>2</mn><mo>+</mo><mi>F</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">F(2n + 1) = F(n)2 + F(n+1)2
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">2</span></span></span></span></span></p>
<pre><code class="language-C++"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">fibonatiMod</span> <span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> n,<span class="hljs-type">long</span> <span class="hljs-type">long</span> mod)</span>
</span>{
    <span class="hljs-type">long</span> <span class="hljs-type">long</span> msb_position = <span class="hljs-number">63</span>;
    <span class="hljs-keyword">while</span> (!((<span class="hljs-number">1</span> &lt;&lt; (msb_position<span class="hljs-number">-1</span>) &amp; n)) &amp;&amp; msb_position &gt;= <span class="hljs-number">0</span>)
        msb_position--;
 
    <span class="hljs-type">long</span> <span class="hljs-type">long</span> a=<span class="hljs-number">0</span>, b=<span class="hljs-number">1</span>; 
 
    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i=msb_position; i&gt;=<span class="hljs-number">0</span>;--i)
    {       
        <span class="hljs-type">long</span> <span class="hljs-type">long</span> d = (a%mod) * ((b%mod)*<span class="hljs-number">2</span> - (a%mod) + mod),
            e = (a%mod) * (a%mod) + (b%mod)*(b%mod);
        a=d%mod;
        b=e%mod;
 
        <span class="hljs-keyword">if</span> (((n &gt;&gt; i) &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>)
        {
            <span class="hljs-type">long</span> <span class="hljs-type">long</span> c = (a + b) % mod;
            a = b;
            b = c;
        }
    }
    <span class="hljs-keyword">return</span> a;
}
</code></pre>
<h1 id="números-primos">Números primos</h1>
<h2 id="checagem-rápida-de-se-um-número-é-primo">Checagem rápida de se um número é primo</h2>
<p>Se retornar false então é 100% de certeza que não é primo, mas não garante que é primo se retornar True. Aumentar o <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> aumenta a certeza.</p>
<pre><code class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">isPrime</span>(<span class="hljs-params">n, k=<span class="hljs-number">5</span></span>): <span class="hljs-comment"># miller-rabin</span>
    <span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> randint
    <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>,<span class="hljs-number">17</span>,<span class="hljs-number">19</span>,<span class="hljs-number">23</span>,<span class="hljs-number">29</span>]:
       <span class="hljs-keyword">if</span> n % p == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> n == p
    s, d = <span class="hljs-number">0</span>, n-<span class="hljs-number">1</span>
    <span class="hljs-keyword">while</span> d % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:
        s, d = s+<span class="hljs-number">1</span>, d//<span class="hljs-number">2</span>
    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):
        x = <span class="hljs-built_in">pow</span>(randint(<span class="hljs-number">2</span>, n-<span class="hljs-number">1</span>), d, n)
        <span class="hljs-keyword">if</span> x == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> x == n-<span class="hljs-number">1</span>: <span class="hljs-keyword">continue</span>
        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, s):
            x = (x * x) % n
            <span class="hljs-keyword">if</span> x == <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
            <span class="hljs-keyword">if</span> x == n-<span class="hljs-number">1</span>: <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">else</span>: <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
</code></pre>
<h2 id="fatorização-de-um-número">Fatorização de um número</h2>
<p>A fatorização de um número é a decomposição de um números pelos seus primos geradores. Por exemplo o número 24 pode ser decomposto em: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>∗</mo><mn>2</mn><mo>∗</mo><mn>2</mn><mo>∗</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">2*2*2*3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> ou <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>3</mn></msup><mo>∗</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">2^3*3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>.</p>
<p>A função abaixo faz a fatorização de um número pelos seus primos. Ela pode ser otimizada se já houver uma lista de primos pré computados. Para primos muito grandes essa função pode levar um tempo para fatorizar.</p>
<pre><code class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">factorization</span>(<span class="hljs-params">number</span>):
    solution = []
    <span class="hljs-keyword">while</span> number&amp;<span class="hljs-number">1</span>==<span class="hljs-number">0</span>:
        number//=<span class="hljs-number">2</span>
        solution.append(<span class="hljs-number">2</span>)
    i = <span class="hljs-number">3</span>
    <span class="hljs-keyword">while</span> math.sqrt(number) &gt; i:
        <span class="hljs-keyword">while</span> number % i == <span class="hljs-number">0</span>:
            number //= i 
            solution.append(i)
        i += <span class="hljs-number">2</span>
    <span class="hljs-keyword">if</span> number!=<span class="hljs-number">1</span>:
        solution.append(number)
    <span class="hljs-keyword">return</span> solution
</code></pre>
<h2 id="se-tiver-um-sieve-pré-computado-até-sqrtn-é-melhor-usar-essa-versão">Se tiver um sieve pré-computado (até sqrt(n)) é melhor usar essa versão:</h2>
<pre><code class="language-python"><span class="hljs-keyword">import</span> math
<span class="hljs-keyword">import</span> timeit

<span class="hljs-keyword">def</span> <span class="hljs-title function_">factor</span>(<span class="hljs-params">n, primes</span>):
    <span class="hljs-string">&quot;Prime factors of n.&quot;</span>
    <span class="hljs-comment"># factor(99) --&gt; 3 3 11</span>
    <span class="hljs-keyword">for</span> prime <span class="hljs-keyword">in</span> primes:
        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
            quotient, remainder = <span class="hljs-built_in">divmod</span>(n, prime)
            <span class="hljs-keyword">if</span> remainder:
                <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">yield</span> prime
            n = quotient
            <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:
                <span class="hljs-keyword">return</span>
    <span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">1</span>:
        <span class="hljs-keyword">yield</span> n

n = <span class="hljs-number">1_000_000</span>
primes = sieve(math.isqrt(n) + <span class="hljs-number">1</span>) <span class="hljs-comment"># isqrt é a int(sqrt(n)) ou raiz inteira</span>
</code></pre>
<h2 id="algoritmo-sieve-pré-computar-primos">Algoritmo Sieve (Pré-computar primos)</h2>
<pre><code class="language-python"><span class="hljs-keyword">import</span> math
<span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> compress
<span class="hljs-keyword">import</span> timeit

<span class="hljs-keyword">def</span> <span class="hljs-title function_">sieve</span>(<span class="hljs-params">n</span>):
    <span class="hljs-string">&quot;Primes less than n&quot;</span>
    <span class="hljs-comment"># sieve(30) --&gt; 2 3 5 7 11 13 17 19 23 29</span>
    data = <span class="hljs-built_in">bytearray</span>((<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) * (n // <span class="hljs-number">2</span>)
    data[:<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>
    limit = math.isqrt(n) + <span class="hljs-number">1</span>
    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> compress(<span class="hljs-built_in">range</span>(limit), data):
        data[p*p : n : p+p] = <span class="hljs-built_in">bytes</span>(<span class="hljs-built_in">len</span>(<span class="hljs-built_in">range</span>(p*p, n, p+p)))
    data[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>
    i = -<span class="hljs-number">1</span>
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
            <span class="hljs-keyword">yield</span> (i := data.index(<span class="hljs-number">1</span>, i+<span class="hljs-number">1</span>))
    <span class="hljs-keyword">except</span> ValueError:
        <span class="hljs-keyword">pass</span>

</code></pre>
<h2 id="prime-factor">Prime Factor</h2>
<p>Retorna o menor fator primo de um valor n.</p>
<p>Ex: 6 = 2 * 3. No caso o menor valor é o 2 então este será retornado.
Se n for primo, o próprio n será retornado.</p>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">primeFactor</span> <span class="hljs-params">(<span class="hljs-type">int</span> n)</span>
</span>{
	<span class="hljs-comment">// Don&#x27;t bother to use abs () &lt;stdlib.h&gt;</span>
	<span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>)
		n = -n;
	<span class="hljs-comment">// For n &lt; 2; it is just n</span>
	<span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>)
		<span class="hljs-keyword">return</span> n;

	<span class="hljs-comment">// otherwise, for an even number it is 2</span>
	<span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)
		<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;

	<span class="hljs-comment">// for other odd numbers, search for a divisor</span>
	<span class="hljs-comment">// until SQRT (n) [conceptual] n / div &gt;= div is</span>
	<span class="hljs-comment">// equivalent to SQRT (n) &gt;= div</span>
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> div = <span class="hljs-number">3</span>; n / div &gt;= div; div += <span class="hljs-number">2</span>)
	{
		<span class="hljs-comment">// if div is a divisor, just return it.</span>
		<span class="hljs-keyword">if</span> (n % div == <span class="hljs-number">0</span>)
			<span class="hljs-keyword">return</span> div;
	}

	<span class="hljs-comment">// There is no divisor (n is prime), return it.</span>
	<span class="hljs-keyword">return</span> n;
}
</code></pre>
<h1 id="aritimética-modular">Aritimética modular</h1>
<p>Dado um inteiro <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n \gt 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> , chamado módulo, e dois inteiros <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> e <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> são ditos congruentes módulo <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>, se e somente se <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> é um divisor da diferença entre eles.</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>a</mi><mo>−</mo><mi>b</mi><mo>=</mo><mi>k</mi><mo>∗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">    a - b = k*n
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span></p>
<p>Para <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>∈</mo><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">k \in \mathbb{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">Z</span></span></span></span></p>
<p>Logo é dito que:</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>a</mi><mo>≡</mo><mi>b</mi><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">    a \equiv b (\mathrm{mod}\ n)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">mod</span></span><span class="mspace"> </span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p>
<p>Note que pela notação o trecho <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\mathrm{mod}\ n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">mod</span></span><span class="mspace"> </span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> deve aparecer sempre ao lado direito da equação e é aplicado a ambos os lados da equação, e não só ao lado em que ele aparece. Ou seja, ambos os exemplos abaixo são verdade:</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>4</mn><mo>≡</mo><mn>9</mn><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mn>5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">    4 \equiv 9 (\mathrm{mod}\ 5)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">9</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">mod</span></span><span class="mspace"> </span><span class="mord">5</span><span class="mclose">)</span></span></span></span></span></p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>9</mn><mo>≡</mo><mn>4</mn><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mn>5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">    9 \equiv 4 (\mathrm{mod}\ 5)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">mod</span></span><span class="mspace"> </span><span class="mord">5</span><span class="mclose">)</span></span></span></span></span></p>
<h2 id="propriedades">Propriedades</h2>
<p>Primeiramente, a relação de módulo satisfazem todas as condições de relação de equivalência:</p>
<ul>
<li>Reflexividade: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≡</mo><mi>a</mi><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a\equiv a(\mathrm{mod}\ n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">mod</span></span><span class="mspace"> </span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
<li>Simetria: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≡</mo><mi>b</mi><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a\equiv b(\mathrm{mod}\ n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">mod</span></span><span class="mspace"> </span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> se <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>≡</mo><mi>a</mi><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">b\equiv a(\mathrm{mod}\ n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">mod</span></span><span class="mspace"> </span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> para todo <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> e <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></li>
<li>Transitividade: Se <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≡</mo><mi>b</mi><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a\equiv b(\mathrm{mod}\ n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">mod</span></span><span class="mspace"> </span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> e <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>≡</mo><mi>c</mi><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">b\equiv c(\mathrm{mod}\ n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">mod</span></span><span class="mspace"> </span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> então <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≡</mo><mi>c</mi><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a\equiv c(\mathrm{mod}\ n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">mod</span></span><span class="mspace"> </span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
</ul>
<p>Seja <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>≡</mo><msub><mi>b</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a_1 \equiv b_1 (\mathrm{mod}\ n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6138em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">mod</span></span><span class="mspace"> </span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>2</mn></msub><mo>≡</mo><msub><mi>b</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a_2 \equiv b_2 (\mathrm{mod}\ n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6138em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">mod</span></span><span class="mspace"> </span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> e <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≡</mo><mi>b</mi><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a \equiv b (\mathrm{mod}\ n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">mod</span></span><span class="mspace"> </span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> e <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>∈</mo><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">k \in \mathbb{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">Z</span></span></span></span> então:</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mi>k</mi><mo>≡</mo><mi>b</mi><mo>+</mo><mi>k</mi><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a+k\equiv b+k (\mathrm{mod}\ n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">mod</span></span><span class="mspace"> </span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi mathvariant="normal">.</mi><mi>k</mi><mo>≡</mo><mi>b</mi><mi mathvariant="normal">.</mi><mi>k</mi><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a.k\equiv b.k (\mathrm{mod}\ n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">a</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">mod</span></span><span class="mspace"> </span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi mathvariant="normal">.</mi><mi>k</mi><mo>≡</mo><mi>b</mi><mi mathvariant="normal">.</mi><mi>k</mi><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mi>n</mi><mi mathvariant="normal">.</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a.k\equiv b.k (\mathrm{mod}\ n.k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">a</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">mod</span></span><span class="mspace"> </span><span class="mord mathnormal">n</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><mo>≡</mo><msub><mi>b</mi><mn>1</mn></msub><mo>+</mo><msub><mi>b</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a_1+a_2\equiv b_1+b_2 (\mathrm{mod}\ n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6138em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">mod</span></span><span class="mspace"> </span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> Compatibilidade com soma</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>−</mo><msub><mi>a</mi><mn>2</mn></msub><mo>≡</mo><msub><mi>b</mi><mn>1</mn></msub><mo>+</mo><msub><mi>b</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a_1-a_2\equiv b_1+b_2 (\mathrm{mod}\ n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6138em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">mod</span></span><span class="mspace"> </span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> Compatibilidade com subtração</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mi mathvariant="normal">.</mi><msub><mi>a</mi><mn>2</mn></msub><mo>≡</mo><msub><mi>b</mi><mn>1</mn></msub><mi mathvariant="normal">.</mi><msub><mi>b</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a_1.a_2\equiv b_1.b_2 (\mathrm{mod}\ n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6138em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">mod</span></span><span class="mspace"> </span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> Compatibilidade com multiplicação</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>k</mi></msup><mo>≡</mo><msup><mi>b</mi><mi>k</mi></msup><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a^k\equiv b^k (\mathrm{mod}\ n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">mod</span></span><span class="mspace"> </span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> Para <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> não negativo. Compatibilidade com exponenciação</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>≡</mo><mi>p</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(a)\equiv p(b) (\mathrm{mod}\ n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">mod</span></span><span class="mspace"> </span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> Para qualquer função polinomial <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> com coeficientes inteiros.</li>
</ul>
<h2 id="potencia-com-módulo">Potencia com Módulo</h2>
<p>Para potencia com módulo, em C temos o seguinte código:</p>
<pre><code class="language-c"><span class="hljs-comment">// Fast pow and mod</span>
<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">modpow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> base, <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-built_in">exp</span>, <span class="hljs-type">long</span> <span class="hljs-type">long</span> modulus)</span> {
    base %= modulus;
    T result = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">exp</span> &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span> &amp; <span class="hljs-number">1</span>) result = (result * base) % modulus;
        base = (base * base) % modulus;
        <span class="hljs-built_in">exp</span> &gt;&gt;= <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">return</span> result;
}
</code></pre>
<p>Em python temos a função modpow implementada nativamente na função <code>pow</code>. O primeiro parametro é a base, o segundo o expoente e o terceiro é o módulo.</p>
<h2 id="inverso-modular">Inverso Modular</h2>
<p>O inverso modular de <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> com módulo <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> é um número <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> tal que, quando multiplicado com <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>, gera um valor cujo resto da divisão com <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> é 1. Ou seja, <p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>a</mi><mi>x</mi><mo>≡</mo><mn>1</mn><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ax \equiv1 (\mathrm{mod}\ m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">mod</span></span><span class="mspace"> </span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span></p>
</p>
<p><strong>Notação:</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">a^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><strong>Exemplo:</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">a = 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span> e <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">m = 7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span> resulta em <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">a^{-1} = 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> , pois <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>∗</mo><mn>5</mn><mo>=</mo><mn>15</mn></mrow><annotation encoding="application/x-tex">3 * 5 = 15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">15</span></span></span></span> e <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>15</mn><mo>≡</mo><mn>1</mn><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mn>7</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">15 \equiv1 (\mathrm{mod}\ 7)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">15</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">mod</span></span><span class="mspace"> </span><span class="mord">7</span><span class="mclose">)</span></span></span></span></p>
<p><strong>OBS:</strong> O inverso modular existe se, e somente se, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> e <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> forem coprimos (ou primos entre si), isto é: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>d</mi><mi>c</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">mdc(a, m) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">d</span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>.</p>
<p>O algoritmo para calcular o inverso modular utiliza o algoritmo extendido de Euclides (<code>egcd</code>). Note que a função <code>modInv</code> retorna 0 caso não exista o inverso modular. É interessante apontar que questões que envolvem módulo - na maioria das vezes - possuem um número <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> primo (geralemente, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">10^9 + 7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span>). Isso garante que o inverso modular irá existir caso <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> não seja múltiplo de <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>. Portanto, dependendo da questão, pode-se remover a verificação da função <code>modInv</code>.</p>
<p>(NÃO TESTADO)</p>
<pre><code class="language-python"><span class="hljs-comment"># algoritmo extendido de Euclides</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">egcd</span>(<span class="hljs-params">a, b</span>):
    <span class="hljs-keyword">if</span> a == <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span> (b, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)
    <span class="hljs-keyword">else</span>:
        g, y, x = egcd(b % a, a)
        <span class="hljs-keyword">return</span> (g, x - (b // a) * y, y)

<span class="hljs-comment"># a^-1 mod m = 1</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">modInv</span>(<span class="hljs-params">a, m</span>):
    g, x, y = egcd(a, m)
    <span class="hljs-keyword">if</span> g != <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-comment"># inverso modular não existe</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> x % m
</code></pre>
<h1 id="combinatória-modular">Combinatória modular</h1>
<p>Fermat’s little theorem and modular inverse
Fermat’s little theorem states that if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> is a prime number, then for any integer a, the number <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>p</mi></msup><mtext>–</mtext><mi>a</mi></mrow><annotation encoding="application/x-tex">a^p – a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span><span class="mord">–</span><span class="mord mathnormal">a</span></span></span></span> is an integer multiple of p. In the notation of modular arithmetic, this is expressed as:</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>a</mi><mi>p</mi></msup><mo>=</mo><mi>a</mi><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a^p = a (\mathrm{mod}\ p) 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7144em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">mod</span></span><span class="mspace"> </span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span></span></p>
<p>For example, if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">a = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">p = 7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span> so <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>7</mn></msup><mo>=</mo><mn>128</mn></mrow><annotation encoding="application/x-tex">2^7 = 128</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">128</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>128</mn><mtext>–</mtext><mn>2</mn><mo>=</mo><mn>7</mn><mo>×</mo><mn>18</mn></mrow><annotation encoding="application/x-tex">128 – 2 = 7 × 18</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">128–2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">18</span></span></span></span> is an integer multiple of 7.</p>
<p>If a is not divisible by p, Fermat’s little theorem is equivalent to the statement <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mrow><mi>p</mi><mtext>–</mtext><mn>1</mn></mrow></msup><mtext>–</mtext><mn>1</mn></mrow><annotation encoding="application/x-tex">a^{p–1} – 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mtight">–1</span></span></span></span></span></span></span></span></span><span class="mord">–1</span></span></span></span> is an integer multiple of p, i.e</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>a</mi><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><mn>1</mn><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a^{p-1} = 1 (\mathrm{mod}\ p)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8641em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">mod</span></span><span class="mspace"> </span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span></span></p>
<p>If we multiply both sides by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">a^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>, we get.</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>a</mi><mrow><mi>p</mi><mo>−</mo><mn>2</mn></mrow></msup><mo>=</mo><msup><mi>a</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a^{p-2} = a^{-1} (\mathrm{mod}\ p)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8641em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">mod</span></span><span class="mspace"> </span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span></span></p>
<p>Código em python: (Precisa testar, não acredito que esteja dando a resposta certa)</p>
<pre><code class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">ncr</span>(<span class="hljs-params">n, r, p</span>):
    <span class="hljs-comment"># initialize numerator and denominator</span>
    num = den = <span class="hljs-number">1</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(r):
        num = (num * (n - i)) % p
        den = (den * (i + <span class="hljs-number">1</span>)) % p
    <span class="hljs-keyword">return</span> (num * <span class="hljs-built_in">pow</span>(den, p - <span class="hljs-number">2</span>, p)) % p
</code></pre>
<p>Dicas de otimização:</p>
<ul>
<li>Se o <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> é constante, é possivel pre-computalo no inicio do programa.</li>
<li>Se o <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> é constante, é possivel pré-computar.</li>
</ul>
<p>Exemplo do programa em c++:</p>
<pre><code class="language-c++"><span class="hljs-comment">// fatorial já ta pre computado FAT[]</span>
<span class="hljs-comment">// invFatorial também INV[]</span>

<span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> MOD = XXXXXX    <span class="hljs-comment">// Funciona apenas para primos entre si, ou seja, se o MOD for primo vai funcionar</span>
invFatoria[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>

<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>;x&lt;LIMIT;x++){
   invFatorial[x] = <span class="hljs-built_in">pow</span>(i,MOD<span class="hljs-number">-2</span>);
}

<span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">comb_mob</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> n, <span class="hljs-type">long</span> <span class="hljs-type">long</span> p)</span>
</span>{
   <span class="hljs-comment">// O resto da divisão de (n p) = (n!/(p!(n-p)!)) modulo q poder ser calculado da senguinte forma:</span>
   <span class="hljs-comment">// FAT[n]*INV[n-p]*INV[p]%MOD</span>
   <span class="hljs-type">long</span> <span class="hljs-type">long</span> resp = fatorial[n]*invFatorial[n-p];
   resp %= MOD;
   resp *= invFatorial[p];
   resp %= MOD;
   <span class="hljs-keyword">return</span> resp;
}
</code></pre>
<h2 id="máximo-divisor-comum">Máximo Divisor Comum</h2>
<p>Calcula o máximo divisor entre 'a' e 'b'</p>
<p>Ex: mdc(12, 8) = 4</p>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mdc</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{ 
   <span class="hljs-keyword">while</span> (b &gt; <span class="hljs-number">0</span>) { 
      a = a % b; 
      a ^= b;    b ^= a;    a ^= b;  
   }  
   <span class="hljs-keyword">return</span> a; 
} 
</code></pre>
<h2 id="mínimo-múltiplo-comum">Mínimo Múltiplo Comum</h2>
<p>Procura o menor valor que seja múltiplo de 'a' e 'b'</p>
<p>Ex: mmc(3, 4) = 12</p>
<p><strong>OBS: Utiliza a fórmula do mdc</strong></p>
<pre><code class="language-c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span> <span class="hljs-comment">/*para poder utilizar o abs(int)*/</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mmc</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>
</span>{
   <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a * b) / <span class="hljs-built_in">mdc</span>(a,b);
}
</code></pre>
<p><strong>OBS: mmc(a, b, c) = mmc(mmc(a, b), c)</strong></p>
<h1 id="em-python-melhor">Em Python (melhor)</h1>
<pre><code class="language-python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> gcd, lcm

<span class="hljs-built_in">print</span>(gcd(<span class="hljs-number">12</span>,<span class="hljs-number">8</span>)) <span class="hljs-comment"># maior divisor comum</span>
<span class="hljs-comment"># 4</span>

<span class="hljs-built_in">print</span>(lcm(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)) <span class="hljs-comment"># menor multiplo comum</span>
<span class="hljs-comment"># 12</span>

<span class="hljs-comment"># Função feita na mão:</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">mdc</span>(<span class="hljs-params">a, b</span>):
    <span class="hljs-keyword">while</span> b &gt; <span class="hljs-number">0</span>:
        a = a % b
        a ^= b
        b ^= a
        a ^= b
    <span class="hljs-keyword">return</span> a
</code></pre>
<h1 id="area-de-formas">Area de Formas</h1>
<h2 id="triangulos-fórmula-de-herão">Triangulos (Fórmula de Herão)</h2>
<p>Formula geral usando semi perimetro e seja tamanho dos lados do triangulo <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> e <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>.</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>p</mi><mo>=</mo><mfrac><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>+</mo><mi>c</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">    p = \frac{a+b+c}{2}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0574em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mo>=</mo><msqrt><mrow><mi>p</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>a</mi><mo>−</mo><mi>p</mi><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><mi>b</mi><mo>−</mo><mi>p</mi><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><mi>c</mi><mo>−</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></msqrt></mrow><annotation encoding="application/x-tex">    A = \sqrt{p*(a-p)*(b-p) * (c-p)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.2561em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9839em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span><span style="top:-2.9439em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l0 -0
c4.7,-7.3,11,-11,19,-11
H40000v40H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M1001 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2561em;"><span></span></span></span></span></span></span></span></span></span></p>
<h2 id="área-de-polígonos-regulares-de-n-lados-e-lado-l">Área de Polígonos Regulares (de <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> lados e lado <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>)</h2>
<p><strong>Definição:</strong> Um polígono regular é <strong>CONVEXO</strong> e possui todos os lados e ângulos <strong>IGUAIS</strong>.</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> é o apótema (tamanho do segmento que liga o centro ao ponto médio de um dos lados fazendo um ângulo de 90 graus)</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> é o perímetro (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>∗</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">n * l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>)</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mo>=</mo><mfrac><mrow><mi>p</mi><mo>∗</mo><mi>a</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">    A = \frac{p * a}{2}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.8283em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1423em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<h2 id="lista-de-apótemas">Lista de apótemas</h2>
<ul>
<li>triângulo: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mfrac><mrow><mi>l</mi><mo>∗</mo><msqrt><mn>2</mn></msqrt></mrow><mn>6</mn></mfrac></mrow><annotation encoding="application/x-tex">a = \frac{l * \sqrt{2}}{6}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.383em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.038em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.399em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">∗</span><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9128em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;"><span class="mord mtight">2</span></span></span><span style="top:-2.8728em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1272em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
<li>quadrado: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mfrac><mi>l</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">a = \frac{l}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2251em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
<li>hexágono: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mfrac><mrow><mi>l</mi><mo>∗</mo><msqrt><mn>3</mn></msqrt></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">a = \frac{l * \sqrt{3}}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.383em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.038em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.399em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">∗</span><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9128em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;"><span class="mord mtight">3</span></span></span><span style="top:-2.8728em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1272em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
</ul>
<h1 id="algoritmos-de-busca">Algoritmos de Busca</h1>
<h2 id="busca-binária">Busca Binária</h2>
<pre><code class="language-c++"><span class="hljs-comment">/*faz uma busca binaria em vetor a procura pelo indice do valor que seja maior ou igual a val. */</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">busca</span><span class="hljs-params">(<span class="hljs-type">int</span> *vet, <span class="hljs-type">int</span> val, <span class="hljs-type">int</span> tamanho)</span>
</span>{
    <span class="hljs-type">int</span> ini = <span class="hljs-number">0</span>, fim = tamanho<span class="hljs-number">-1</span>;

    <span class="hljs-keyword">if</span>(val &gt; vet[fim] )
        <span class="hljs-keyword">return</span> tamanho;
    <span class="hljs-keyword">if</span>(val &lt; vet[<span class="hljs-number">0</span>] )  <span class="hljs-comment">//aumentou o desempenho</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-type">int</span> achou = tamanho; <span class="hljs-comment">/*posicao fora do range = nao achou*/</span>
    <span class="hljs-keyword">while</span>(ini &lt;= fim)
    {
        <span class="hljs-type">int</span> meio = (ini + fim )/<span class="hljs-number">2</span>;
        <span class="hljs-type">int</span> elem = vet[meio];
        <span class="hljs-keyword">if</span>( elem &gt;= val )
        {
            achou = meio;
            fim = meio - <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-comment">/*if( elem &lt; val ) */</span>
            ini = meio + <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">return</span> achou;
}
</code></pre>
<h1 id="busca-binária-em-c">Busca binária em C++</h1>
<h2 id="stdsort">std::sort</h2>
<pre><code class="language-c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>)</span></span>;

    <span class="hljs-comment">// ordena bem default msm</span>
    <span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(),vec.<span class="hljs-built_in">end</span>());

    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">l</span>{
        <span class="hljs-type">int</span> a,b;
    };

    vector&lt;<span class="hljs-keyword">struct</span> l&gt; vec2;

    vec2.<span class="hljs-built_in">push_back</span>({<span class="hljs-number">1</span>,<span class="hljs-number">2</span>});
    vec2.<span class="hljs-built_in">push_back</span>({<span class="hljs-number">5</span>,<span class="hljs-number">7</span>});
    vec2.<span class="hljs-built_in">push_back</span>({<span class="hljs-number">3</span>,<span class="hljs-number">1</span>});
    vec2.<span class="hljs-built_in">push_back</span>({<span class="hljs-number">9</span>,<span class="hljs-number">2</span>});
    vec2.<span class="hljs-built_in">push_back</span>({<span class="hljs-number">2</span>,<span class="hljs-number">6</span>});  
    <span class="hljs-comment">// Ordena vetor de struct</span>
    <span class="hljs-built_in">sort</span>(vec2.<span class="hljs-built_in">begin</span>(),vec2.<span class="hljs-built_in">end</span>(),
        <span class="hljs-comment">// Lambda function in C++ OMG!!!!!</span>
        [](<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> l&amp; s1,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> l&amp; s2 ){
            <span class="hljs-keyword">if</span>(s1.a==s2.a)<span class="hljs-keyword">return</span> s1.b &lt; s2.b; 
            <span class="hljs-keyword">return</span> s1.a &lt; s2.a;
        });

}

</code></pre>
<h2 id="stdlower_bound--stdupper_bound">std::lower_bound / std::upper_bound</h2>
<pre><code class="language-c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-comment">// Vetor ordenado</span>
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>)</span></span>;

    <span class="hljs-comment">// retorna um iterador para o menor elemento que é maior ou igual ao valor passado</span>
    <span class="hljs-keyword">auto</span> it1 = <span class="hljs-built_in">lower_bound</span>(vec.<span class="hljs-built_in">begin</span>(),vec.<span class="hljs-built_in">end</span>(),<span class="hljs-number">5</span>);
    <span class="hljs-comment">// retorna um iterador para o maior elemento que é menor ou igual ao valor passado</span>
    <span class="hljs-keyword">auto</span> it2 = <span class="hljs-built_in">upper_bound</span>(vec.<span class="hljs-built_in">begin</span>(),vec.<span class="hljs-built_in">end</span>(),<span class="hljs-number">4</span>);

    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">l</span>{
        <span class="hljs-type">int</span> a,b;
    };

    <span class="hljs-comment">// Vetor ordenado</span>
    vector&lt;<span class="hljs-keyword">struct</span> l&gt; vec2;

    <span class="hljs-comment">// retorna um iterador para o menor elemento que é maior ou igual ao valor passado</span>
    <span class="hljs-keyword">auto</span> it3 = <span class="hljs-built_in">lower_bound</span>(vec.<span class="hljs-built_in">begin</span>(),vec.<span class="hljs-built_in">end</span>(),<span class="hljs-number">5</span>,
        [](<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> l&amp; s1,<span class="hljs-type">const</span> <span class="hljs-type">int</span> v ){ <span class="hljs-comment">// LAMBDA FUNCTION IN C++ OMG!!!!</span>
            <span class="hljs-keyword">return</span> s1.a &lt; v;
        });
    <span class="hljs-comment">// retorna um iterador para o maior elemento que é menor ou igual ao valor passado</span>
    <span class="hljs-keyword">auto</span> it4 = <span class="hljs-built_in">upper_bound</span>(vec.<span class="hljs-built_in">begin</span>(),vec.<span class="hljs-built_in">end</span>(),<span class="hljs-number">4</span>,
        [](<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> l&amp; s1,<span class="hljs-type">const</span> <span class="hljs-type">int</span> v ){ <span class="hljs-comment">// OTHER LAMBDA FUNCTION IN C++ OMG!!!!</span>
            <span class="hljs-keyword">return</span> s1.a &lt; v;
        });

}
</code></pre>
<h2 id="stddistance">std::distance</h2>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-comment">// Vetor ordenado</span>
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>)</span></span>;

    <span class="hljs-comment">// retorna um iterador para o menor elemento que é maior ou igual ao valor passado</span>
    <span class="hljs-keyword">auto</span> it1 = <span class="hljs-built_in">lower_bound</span>(vec.<span class="hljs-built_in">begin</span>(),vec.<span class="hljs-built_in">end</span>(),<span class="hljs-number">5</span>);
    <span class="hljs-type">int</span> idx1 = <span class="hljs-built_in">distance</span>(vec.<span class="hljs-built_in">begin</span>(),it1);

    <span class="hljs-comment">// retorna um iterador para o maior elemento que é menor ou igual ao valor passado</span>
    <span class="hljs-keyword">auto</span> it2 = <span class="hljs-built_in">upper_bound</span>(vec.<span class="hljs-built_in">begin</span>(),vec.<span class="hljs-built_in">end</span>(),<span class="hljs-number">4</span>);
    <span class="hljs-type">int</span> idx2 = <span class="hljs-built_in">distance</span>(vec.<span class="hljs-built_in">begin</span>(),it2);

}
</code></pre>
<h1 id="grafos">Grafos</h1>
<h1 id="passeios-eulerianos">Passeios Eulerianos</h1>
<p>Um passeio Euleriano em um grafo conexo é um passeio fechado que usa cada aresta do grafo exatamente uma vez. Um grafo conexo é Euleriano se contiver um passeio Euleriano.</p>
<h2 id="as-pontes-de-königsberg">As Pontes de Königsberg</h2>
<p>Discutia-se nas ruas da cidade a possibilidade de atravessar todas as pontes sem repetir nenhuma. Havia-se tornado uma lenda popular a possibilidade da façanha quando Euler, em 1736, provou que não existia caminho que possibilitasse tais restrições.</p>
<p>Euler transformou os caminhos em retas e suas intersecções em pontos, criando possivelmente o primeiro grafo da história. Então percebeu que só seria possível atravessar o caminho inteiro passando uma única vez em cada ponte se houvesse exatamente zero ou dois pontos de onde tivessem um número ímpar de caminhos.</p>
<p>A razão de tal coisa é que de cada ponto deve haver um número par de caminhos, pois será preciso um caminho para &quot;entrar&quot;e outro para &quot;sair&quot;. Os dois pontos com caminhos ímpares referem-se ao início e ao final do percurso, pois estes não precisam de um para entrar e um para sair, respectivamente. Se não houver pontos com número ímpar de caminhos, pode-se (e deve-se) iniciar e terminar o trajeto no mesmo ponto, podendo esse ser qualquer ponto do grafo. Isso não é possível quando temos dois pontos com números ímpares de caminhos, sendo obrigatoriamente um o início e outro o fim.</p>
<h1 id="fluid-fill">Fluid Fill</h1>
<h2 id="versão-recursiva">Versão recursiva</h2>
<p>A versão recursiva é a mais fácil de entender o algoritmo, então segue o código:</p>
<pre><code class="language-python">
<span class="hljs-keyword">def</span> <span class="hljs-title function_">floodFill</span>(<span class="hljs-params">matrix,x,y,cache: <span class="hljs-built_in">set</span></span>):
    restrictedValue = matrix[x][y]
    cont = <span class="hljs-number">1</span>
    cache.add((x,y))  <span class="hljs-comment"># Add this position to set</span>
    
    <span class="hljs-keyword">for</span> a,b <span class="hljs-keyword">in</span> [(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>),(-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>),(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>),(<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>)]:
        <span class="hljs-comment"># new position</span>
        nX,nY = x+a,y+b
        <span class="hljs-comment"># check if x and y is valid positions in the matrix</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (<span class="hljs-number">0</span> &lt;= nX &lt; <span class="hljs-built_in">len</span>(matrix) <span class="hljs-keyword">and</span> <span class="hljs-number">0</span>&lt;= nY &lt; <span class="hljs-built_in">len</span>(matrix[nX])):
            <span class="hljs-keyword">continue</span>

        <span class="hljs-comment"># check if new positions is valid to go and if this positions has not been visited</span>
        <span class="hljs-keyword">if</span> matrix[nX][nY] == restrictedValue <span class="hljs-keyword">and</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> cache:
            cont += floodFill(matrix,nX,nY,cache)

    <span class="hljs-keyword">return</span> cont

</code></pre>
<h2 id="versão-não-recursiva">Versão não recursiva</h2>
<pre><code class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">floodFill</span>(<span class="hljs-params">matrix,x,y</span>):
    restrictedValue = matrix[x][y]
    buffer = [(x,y)]

    <span class="hljs-comment"># the directions to go</span>
    directions = [(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>),(-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>),(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>),(<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>)]
    cache = <span class="hljs-built_in">set</span>()
    cache.add((x,y))
    cont = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(buffer)&gt;<span class="hljs-number">0</span>:
        <span class="hljs-comment"># remove 1 position to process</span>
        x,y = buffer.pop()
        <span class="hljs-comment"># increment count</span>
        cont += <span class="hljs-number">1</span>

        <span class="hljs-keyword">for</span> a,b <span class="hljs-keyword">in</span> directions:
            <span class="hljs-comment"># new position</span>
            key = (x+a,y+b)
            <span class="hljs-comment"># check if x and y is valid positions in the matrix</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (<span class="hljs-number">0</span> &lt;= key[<span class="hljs-number">0</span>] &lt; <span class="hljs-built_in">len</span>(matrix) <span class="hljs-keyword">and</span> <span class="hljs-number">0</span>&lt;= key[<span class="hljs-number">1</span>] &lt; <span class="hljs-built_in">len</span>(matrix[key[<span class="hljs-number">0</span>]])):
                <span class="hljs-keyword">continue</span>

            <span class="hljs-comment"># check if new positions is valid to go and if this positions has not been visited</span>
            <span class="hljs-keyword">if</span> matrix[key[<span class="hljs-number">0</span>]][key[<span class="hljs-number">1</span>]] == restrictedValue <span class="hljs-keyword">and</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> cache:
                buffer.append(key)
                cache.add(key)  <span class="hljs-comment"># Add position to set</span>
    <span class="hljs-keyword">return</span> cont
</code></pre>
<h1 id="algoritmo-de-dijkstra">Algoritmo de Dijkstra</h1>
<pre><code class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dijkstra</span>(<span class="hljs-params">nodes,src</span>):
    <span class="hljs-string">&quot;&quot;&quot;
        complexity: O(m*log(n))
        m = edges
        n = nodes

        this function return a list of distances from src

        can be faster if you implement heapDictionary (maybe?, in C++ using heapDictionary is faster, but in python i dont think...)
    &quot;&quot;&quot;</span>
    inf = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)
    queue = []
    dist = [inf] * <span class="hljs-built_in">len</span>(nodes)

    heapq.heappush(queue,(<span class="hljs-number">0</span>,src))
    dist[src] = <span class="hljs-number">0</span>

    <span class="hljs-keyword">while</span> queue:
        d,node = heapq.heappop(queue)
        <span class="hljs-keyword">if</span> d &gt; dist[node]:
            <span class="hljs-keyword">continue</span>
        
        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> nodes[node]:
            weigth = nodes[node][child]
            aux = dist[node] + weigth
            <span class="hljs-keyword">if</span> dist[child] &gt; aux:
                dist[child] = aux
                heapq.heappush(queue,(aux,child))
    <span class="hljs-keyword">return</span> dist
</code></pre>
<h2 id="apsp">APSP</h2>
<pre><code class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dijkstra_apsp</span>(<span class="hljs-params">nodes</span>):
    <span class="hljs-string">&quot;&quot;&quot;
        complexity: O(n*m*log(n))
        m = edges
        n = nodes


        this function recive a list of nodes from a graph that can be directed or not
        this function return a matriz of shortest path from every node to other node
    &quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> [dijkstra(nodes,i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nodes))]

</code></pre>
<h1 id="bellman-ford">Bellman-Ford</h1>
<pre><code class="language-python">
<span class="hljs-keyword">def</span> <span class="hljs-title function_">bellmanford</span>(<span class="hljs-params">edges: <span class="hljs-built_in">list</span>,vertices,src</span>):
    <span class="hljs-string">&quot;&quot;&quot;
        complexity: O(m*n)
        m = edges
        n = nodes

        this function recives a directed list of edges that can contain negative weights
        this function return a list of distances from src
        different than dijkstra, the bellman ford can compute correct distances over negative edges
        work in directed graphs, there is no sense a non directed graph with negative edges (think about)

    &quot;&quot;&quot;</span>
    <span class="hljs-comment"># In theory, sort the edges array can make the code fast because of the sequential reading of the array, but in reality this is over engineering</span>
    <span class="hljs-comment"># edges.sort()</span>
    inf = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)
    current = [inf]*vertices
    current[src] = <span class="hljs-number">0</span>

    <span class="hljs-comment">## Optional, only for backtrace</span>
    trace = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(vertices)]

    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,vertices): <span class="hljs-comment"># run n-1 times</span>
        change = <span class="hljs-literal">False</span> <span class="hljs-comment"># premature optimization</span>
        <span class="hljs-keyword">for</span> s,d,w <span class="hljs-keyword">in</span> edges:
            <span class="hljs-keyword">if</span> current[s]!=inf <span class="hljs-keyword">and</span> current[s] + w &lt; current[d]:
                change = <span class="hljs-literal">True</span>
                current[d] = current[s] + w
                <span class="hljs-comment">## Optional, only for backtrace</span>
                trace[d] = s

        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> change: <span class="hljs-comment"># if any change in array ocurr, then already got the final result</span>
            <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">else</span>: <span class="hljs-comment"># Run one more to check infinit loops</span>
        <span class="hljs-comment"># the path between 2 vertices has at max n-1 edges without negative loops, </span>
        <span class="hljs-comment"># if the path has more than n-1 edges, so it has a negative loop in the graph </span>
        <span class="hljs-keyword">for</span> s,d,w <span class="hljs-keyword">in</span> edges:
            <span class="hljs-keyword">if</span> last[s] + w &lt; last[d]:
                <span class="hljs-comment">## 2nd return value is optional, only for backtrace</span>
                <span class="hljs-keyword">return</span> [<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;-inf&#x27;</span>)]*vertices,trace

    <span class="hljs-comment">## 2nd return value is optional, only for backtrace</span>
    <span class="hljs-keyword">return</span> last,trace

</code></pre>
<h1 id="apsp-1">APSP</h1>
<pre><code class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bellmanford_apsp</span>(<span class="hljs-params">edges: <span class="hljs-built_in">list</span>,vertices</span>):
    <span class="hljs-string">&quot;&quot;&quot;
        complexity: O(m*n^2)
        m = edges
        n = nodes

        this function recives a directed list of edges that can contain negative weights
        this function return a list of distances from every pair of nodes
        this is a variation of the original bellmanford algorithm that execute N * belmanford for every vertice

    &quot;&quot;&quot;</span>
    <span class="hljs-comment"># In theory, sort the edges array can make the code fast because of the sequential reading of the array, but in reality this is over engineering</span>
    <span class="hljs-comment"># edges.sort()</span>
    inf = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)
    current = [[inf]*vertices  <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(vertices)]
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(vertices):
        current[i][i] = <span class="hljs-number">0</span>

    <span class="hljs-comment">## Optional, only for backtrace</span>
    trace = [[i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(vertices)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(vertices)]

    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,vertices): <span class="hljs-comment"># run n-1 times</span>
        change = <span class="hljs-literal">False</span> <span class="hljs-comment"># premature optimization</span>
        <span class="hljs-keyword">for</span> s,d,w <span class="hljs-keyword">in</span> edges:

            <span class="hljs-comment"># this for loop can be boosted if implemented using SIMD instructions</span>
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(vertices):
                <span class="hljs-keyword">if</span> current[s][i]!=inf <span class="hljs-keyword">and</span> current[s][i] + w &lt; current[d][i]:
                    change = <span class="hljs-literal">True</span>
                    current[d][i] = current[s][i] + w
                    <span class="hljs-comment">## Optional, only for backtrace</span>
                    trace[d][i] = s

        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> change: <span class="hljs-comment"># if any change in array ocurr, then already got the final result</span>
            <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">else</span>: <span class="hljs-comment"># Run one more to check infinit loops</span>
        <span class="hljs-comment"># the path between 2 vertices has at max n-1 edges without negative loops, </span>
        <span class="hljs-comment"># if the path has more than n-1 edges, so it has a negative loop in the graph </span>
        <span class="hljs-keyword">for</span> s,d,w <span class="hljs-keyword">in</span> edges:
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(vertices):
                <span class="hljs-keyword">if</span> current[s][i] + w &lt; current[d][i]:
                    <span class="hljs-comment">## 2nd return value is optional, only for backtrace</span>
                    <span class="hljs-keyword">return</span> [<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;-inf&#x27;</span>)]*n,trace

    <span class="hljs-comment"># You need to rotate the array, so the src is the first index, and the dst is the second,</span>
    <span class="hljs-comment"># You can skip this if you wish, but the index are reversed, like: result[dst][src] = ShortestPath(src,dst)</span>
    result = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">zip</span>(*current))

    <span class="hljs-comment">## 2nd return value is optional, only for backtrace</span>
    <span class="hljs-keyword">return</span> result,trace

</code></pre>
<h1 id="johnson-algorithm">Johnson Algorithm</h1>
<pre><code class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">johnson</span>(<span class="hljs-params">edges: <span class="hljs-built_in">list</span>, vertices</span>):
    <span class="hljs-string">&quot;&quot;&quot;
        complexity: O(n + m*n + m + n*m log n + n^2) = O(n*m log n)
        m = edges
        n = nodes

        this function recives a directed list of edges that can contain negative weights
        this function return a list of distances from every pair of nodes

    &quot;&quot;&quot;</span>
    <span class="hljs-comment"># Add a new Vertice and add an edge from this vertice to every other vertice with weight zero</span>
    newVertice = vertices
    edges.extend([(newVertice,i,<span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(vertices)])

    <span class="hljs-comment"># Compute a P_v for every vertice</span>
    vW,_ = bellmanford(edges,vertices+<span class="hljs-number">1</span>,newVertice)

    <span class="hljs-comment"># Remove the edges previously added</span>
    <span class="hljs-keyword">del</span> edges[-vertices:]

    <span class="hljs-keyword">if</span> vW[<span class="hljs-number">0</span>] == <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;-inf&#x27;</span>):
        <span class="hljs-keyword">return</span> [[<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;-inf&#x27;</span>)]*vertices <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(vertices)]

    <span class="hljs-comment"># Apply the function to every edge</span>
    newEdges = [(s,d,w+vW[s]-vW[d]) <span class="hljs-keyword">for</span> s,d,w <span class="hljs-keyword">in</span> edges]

    <span class="hljs-comment"># Convert the new edges to a grahp</span>
    nodes = convertEdgesArrayToDirectedSimpleGraph(newEdges,vertices)

    <span class="hljs-comment"># Compute dijkstra to get the APSP</span>
    bestPaths = [dijkstra(nodes,i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(vertices)]

    <span class="hljs-comment"># Correct the values of the paths</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(vertices):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(vertices):
            bestPaths[i][j] = bestPaths[i][j] - vW[i] + vW[j]

    <span class="hljs-keyword">return</span> bestPaths
</code></pre>
<h1 id="prims-algorithm">Prim's Algorithm</h1>
<pre><code class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">primAlgorithm</span>(<span class="hljs-params">graph,initialNode = <span class="hljs-number">0</span></span>):
    <span class="hljs-string">&#x27;&#x27;&#x27;
        complexity: O(m*log(n))
        m = edges
        n = nodes

        this function return a list of edges of MST

        can be faster if you replace s(set) to a array of True or False
            - code needs to be adapted to this change;
    &#x27;&#x27;&#x27;</span>
    s = <span class="hljs-built_in">set</span>()
    s.add(initialNode)
    tree = []

    arr = []
    a = initialNode
    <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> graph[a]:
        heapq.heappush(arr,(graph[a][b],a,b))

    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(s)!=<span class="hljs-built_in">len</span>(graph) <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(arr)&gt;<span class="hljs-number">0</span>:
        (cost,a,b) = heapq.heappop(arr)
        <span class="hljs-keyword">if</span> b <span class="hljs-keyword">in</span> s:
            <span class="hljs-keyword">continue</span>
        
        tree.append((a,b,cost))
        s.add(b)
        
        a = b
        <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> graph[a]:
            <span class="hljs-keyword">if</span> b <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> s:
                heapq.heappush(arr,(graph[a][b],a,b))

        <span class="hljs-keyword">pass</span>
    <span class="hljs-keyword">return</span> tree 
</code></pre>
<h1 id="kruskals-mst">Kruskal's MST</h1>
<pre><code class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">kruskalsMST</span>(<span class="hljs-params">edges: <span class="hljs-built_in">list</span>,nodes: <span class="hljs-built_in">int</span></span>):
    <span class="hljs-string">&#x27;&#x27;&#x27;
        complexity: O(m*alpha(n)) + (sort operation)
        m = edges
        n = nodes

        this function return a list of edges of MST

        can be faster if yout implementation of SetUnion are better
    &#x27;&#x27;&#x27;</span>
    union = DisjointSetUnion(nodes)
    nEdges = []
    edges.sort(key=<span class="hljs-keyword">lambda</span> e: e[<span class="hljs-number">2</span>])
    <span class="hljs-keyword">for</span> (a,b,cost) <span class="hljs-keyword">in</span> edges:
        <span class="hljs-comment"># Check if &#x27;a&#x27; and &#x27;b&#x27; already are in the same cluster</span>
        <span class="hljs-keyword">if</span> union.find(a) != union.find(b):
            union.union(a,b)
            nEdges.append((a,b,cost))
    <span class="hljs-keyword">return</span> nEdges
</code></pre>
<h1 id="espaçamento-entre-clusters">Espaçamento entre clusters</h1>
<pre><code class="language-python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque

<span class="hljs-keyword">class</span> <span class="hljs-title class_">DisjointSetUnion</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, n</span>):
        self.parent = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]
        self.size = [<span class="hljs-number">1</span>] * n
        self.groups = <span class="hljs-built_in">set</span>(self.parent)
 
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">self, x</span>):
       <span class="hljs-keyword">if</span> self.parent[x] != x:
           self.parent[x] = self.find(self.parent[x])
       <span class="hljs-keyword">return</span> self.parent[x] 

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">self, x, y</span>):
        root_x = self.find(x)
        root_y = self.find(y)
        <span class="hljs-keyword">if</span> root_x == root_y:
            <span class="hljs-keyword">return</span>

        <span class="hljs-keyword">if</span> self.size[root_y] &gt; self.size[root_x]:
            root_x, root_y = root_y, root_x
        <span class="hljs-keyword">elif</span> self.size[root_y] == self.size[root_x]:
            self.size[root_x] += <span class="hljs-number">1</span>

        <span class="hljs-comment"># delete root_y group</span>
        self.groups.remove(root_y)
        self.parent[root_y] = root_x
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">num_groups</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.groups)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">maxSpacingClustering</span>(<span class="hljs-params">kClusters: <span class="hljs-built_in">int</span>,nodes: <span class="hljs-built_in">int</span>,edges: <span class="hljs-built_in">list</span></span>):
    edges.sort(reverse=<span class="hljs-literal">True</span>,key=<span class="hljs-keyword">lambda</span> e: e[<span class="hljs-number">2</span>])
    union = DisjointSetUnion(nodes)
    <span class="hljs-comment"># Une os vertices até que sobre apenas k clusters</span>
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(edges)&gt;<span class="hljs-number">0</span>:
        <span class="hljs-comment"># Note que a aresta é removida do array, sabe dizer porque?</span>
        (a,b,_) = edges.pop()
        union.union(a,b)
        <span class="hljs-comment"># Condição de parada</span>
        <span class="hljs-keyword">if</span> union.num_groups()&lt;=kClusters:
            <span class="hljs-keyword">break</span>
    <span class="hljs-comment"># Procura a menor distancia entre 2 clusters</span>
    minCost = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)
    <span class="hljs-keyword">for</span> (a,b,minCost) <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(edges):
        <span class="hljs-keyword">if</span> union.find(a)!=union.find(b):
            <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">return</span> minCost
</code></pre>
<p>Complexidade de tempo: O(M * alpha(n)) + sorting time (M * log M)</p>
<h1 id="perfect-matching-graph">Perfect matching Graph</h1>
<pre><code class="language-python">
<span class="hljs-keyword">def</span> <span class="hljs-title function_">perfectMatchGraph</span>(<span class="hljs-params">graph</span>):
    <span class="hljs-string">&#x27;&#x27;&#x27;
        Check if in one graph every vertice can be matched with other vertice.
            without any vertice stays alone.

        If a vertice is matched with other, it can&#x27;t be matched with any other vertice.
    &#x27;&#x27;&#x27;</span>
    nodes = <span class="hljs-built_in">len</span>(graph)
    vert = [<span class="hljs-built_in">len</span>(graph[a]) <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nodes)]
    hp = [(<span class="hljs-built_in">len</span>(graph[a]),a) <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nodes)]
    heapq.heapify(hp)
    
    revGraph = getReverseGraph(graph)
    
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(hp)&gt;<span class="hljs-number">0</span>:
        g,a = heapq.heappop(hp)
        <span class="hljs-keyword">if</span> vert[a] != g <span class="hljs-keyword">or</span> vert[a]&lt;<span class="hljs-number">0</span>:
            <span class="hljs-keyword">continue</span>
        <span class="hljs-keyword">if</span> g==<span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        
        <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> graph[a]:
            <span class="hljs-keyword">if</span> vert[b]&gt;<span class="hljs-number">0</span>:
                vert[b] = -<span class="hljs-number">1</span>
                vert[a] = -<span class="hljs-number">1</span>
                <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> revGraph[a]:
                    <span class="hljs-keyword">if</span> vert[c] != -<span class="hljs-number">1</span>:
                        vert[c] -= <span class="hljs-number">1</span>
                        heapq.heappush(hp,(vert[c],c))
                <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> revGraph[b]:
                    <span class="hljs-keyword">if</span> vert[c] != -<span class="hljs-number">1</span>:
                        vert[c] -= <span class="hljs-number">1</span>
                        heapq.heappush(hp,(vert[c],c))
                <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(vert)&lt;<span class="hljs-number">0</span>

</code></pre>
<h1 id="funções-conversoras">Funções conversoras</h1>
<pre><code class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">convertEdgesArrayToNonDirectedSimpleGraph</span>(<span class="hljs-params">edges,vertices</span>):
    simplegraph = [{} <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(vertices)]

    <span class="hljs-keyword">for</span> (a,b,cost) <span class="hljs-keyword">in</span> edges:
        simplegraph[a][b] = cost
        simplegraph[b][a] = cost
    <span class="hljs-keyword">return</span> simplegraph

<span class="hljs-keyword">def</span> <span class="hljs-title function_">convertEdgesArrayToDirectedSimpleGraph</span>(<span class="hljs-params">edges,vertices</span>):
    simplegraph = [{} <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(vertices)]

    <span class="hljs-keyword">for</span> (a,b,cost) <span class="hljs-keyword">in</span> edges:
        simplegraph[a][b] = cost
    <span class="hljs-keyword">return</span> simplegraph

<span class="hljs-keyword">def</span> <span class="hljs-title function_">convertSimpleGraphToEdgesArray</span>(<span class="hljs-params">simplegraph</span>):
    edges = []

    <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(simplegraph)):
        <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> simplegraph[a]:
            <span class="hljs-keyword">if</span> a&lt;b:
                edges.append((a,b,simplegraph[a][b]))
    <span class="hljs-keyword">return</span> edges

<span class="hljs-keyword">def</span> <span class="hljs-title function_">convertEdgesArrayToTreeGraph</span>(<span class="hljs-params">edges,vertices</span>):
    FATHER = <span class="hljs-number">0</span>
    CHILD = <span class="hljs-number">1</span>
    treeGraph = [[<span class="hljs-literal">None</span>,[]] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(vertices)]
    simpleGraph = convertEdgesArrayToNonDirectedSimpleGraph(edges,vertices)
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">iterOverGraph</span>(<span class="hljs-params">currentNode,father</span>):
        treeGraph[currentNode][FATHER] = father
        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> simpleGraph[currentNode]:
            <span class="hljs-keyword">if</span> node!=father:
                treeGraph[currentNode][CHILD].append(iterOverGraph(node,currentNode))
        <span class="hljs-keyword">return</span> currentNode
    root = iterOverGraph(<span class="hljs-number">0</span>,<span class="hljs-literal">None</span>)
    <span class="hljs-keyword">return</span> (treeGraph,root)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">getReverseGraph</span>(<span class="hljs-params">graph</span>):
    reverse = [{} <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(graph))]
    <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(graph)):
        <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> graph[a]:
            reverse[b][a] = graph[a][b]
    <span class="hljs-keyword">return</span> reverse

</code></pre>
<h1 id="algoritmos-de-geometria-computacional">Algoritmos de Geometria Computacional</h1>
<h2 id="classe-point-usando-em-alguns-algoritmos">Classe Point (Usando em alguns algoritmos)</h2>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> {
<span class="hljs-keyword">public</span>:
   <span class="hljs-type">float</span> x, y, z;

   <span class="hljs-built_in">Point</span>() {
      x = y = z = <span class="hljs-number">0</span>;
   }

   <span class="hljs-built_in">Point</span>(<span class="hljs-type">float</span> x1, <span class="hljs-type">float</span> y1, <span class="hljs-type">float</span> z1) {
      x = x1;
      y = y1;
      z = z1;
   }

   Point <span class="hljs-keyword">operator</span> - (Point a) {
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>(x - a.x, y - a.y, z - a.z);
   }

   Point <span class="hljs-keyword">operator</span> + (Point a) {
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span> (x + a.x, y + a.y, z + a.z);
   }

   Point <span class="hljs-keyword">operator</span> / (<span class="hljs-type">float</span> a) {
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span> (x / a, y / a, z / a);
   }

   Point <span class="hljs-keyword">operator</span> * (<span class="hljs-type">float</span> a) {
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span> (x * a, y * a, z * a);
   }
};
</code></pre>
<h2 id="polígono">Polígono</h2>
<p>Sendo PI = π</p>
<pre><code class="language-c++"><span class="hljs-comment">/*Fórmula para achar o raio do polígono a partir da área 
&#x27;a&#x27; de um polígono com &#x27;n&#x27; lados*/</span>
raio = <span class="hljs-built_in">sqrt</span>((<span class="hljs-number">2</span>*a)/((<span class="hljs-type">double</span>)n*<span class="hljs-built_in">sin</span>((<span class="hljs-number">2</span>*PI)/(<span class="hljs-type">double</span>)n)));

<span class="hljs-comment">/*lembrando que a área de um polígono pode ser calculada por:*/</span>
area = ((l*raio)/<span class="hljs-number">2.0</span>) * n;
<span class="hljs-comment">/*tendo ‘l’ o comprimento do lado, &#x27;raio&#x27; sendo o raio do círculo o qual o polígono é circunscrito (apótema) e
‘n’ o número de lados do polígono:*/</span>

<span class="hljs-comment">/*Fórmula da apótema do polígono usando o raio encontrado na fórmula acima*/</span>
apotema = <span class="hljs-built_in">cos</span>(PI/(<span class="hljs-type">double</span>)n) * raio;

<span class="hljs-comment">/*Área de um círculo inscrito em um polígono baseado na apótema encontrada na fórmula acima*/</span>
area1 = PI*apotema*apotema;

<span class="hljs-comment">/*Área de um círculo circunscrito num polígono com o raio encontrado acima*/</span>
area2 = PI*raio*raio;

<span class="hljs-comment">/* Calcula a area de um poligono irregular */</span>

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> {
	<span class="hljs-type">float</span> x, y;
};

<span class="hljs-comment">//numP = número de pontos</span>
<span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">area_do_poligono</span><span class="hljs-params">(Point v[], <span class="hljs-type">int</span> numP)</span>
</span>{
	<span class="hljs-type">float</span> area = (v[numP - <span class="hljs-number">1</span>].y + v[<span class="hljs-number">0</span>].y) * (v[numP - <span class="hljs-number">1</span>].x - v[<span class="hljs-number">0</span>].x);

	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numP - <span class="hljs-number">1</span>; i++)
    	{
		area += (v[i].y + v[i + <span class="hljs-number">1</span>].y) * (v[i].x - v[i + <span class="hljs-number">1</span>].x);
	}

	<span class="hljs-keyword">if</span> (area &lt; <span class="hljs-number">0</span>)
		area *= <span class="hljs-number">-1</span>;

	<span class="hljs-keyword">return</span> area / <span class="hljs-number">2</span>;
}

</code></pre>
<h2 id="centro-de-um-círculo-a-partir-de-3-pontos-pontos-cocirculares">Centro de um círculo a partir de 3 pontos (pontos cocirculares)</h2>
<p>Resulta no circCentro que é o centro do círculo.</p>
<pre><code class="language-c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> {
   	<span class="hljs-type">double</span> x,y;
}Point;

Point A,B,C;
Point circCentro;

<span class="hljs-type">double</span> D = <span class="hljs-number">2.0</span> * (A.x * (B.y - C.y) + B.x * (C.y - A.y) + C.x * (A.y - B.y));
<span class="hljs-keyword">if</span> (D==<span class="hljs-number">0.0</span>) { <span class="hljs-comment">/*Não existe círculo pois são colineares*/</span> }
circCentro.x = ((A.y*A.y + A.x*A.x) * (B.y - C.y) + (B.y*B.y + B.x*B.x) * (C.y - A.y) + (C.y*C.y + C.x*C.x) * (A.y - B.y))/D;
circCentro.y = ((A.y*A.y + A.x*A.x) * (C.x - B.x) + (B.y*B.y + B.x*B.x) * (A.x - C.x) + (C.y*C.y + C.x*C.x) * (B.x - A.x))/D;
</code></pre>
<h2 id="área-de-triângulo">Área de Triângulo</h2>
<p>Fórmula denominada Heron of Alexandria</p>
<p>Calcular a área A de um triângulo cujas arestas são de tamanho a, b e c.
Se Tivermos os vértices A B C do triângulo basta que 'a' 'b' e 'c' sejam os resultados dos cálculos das distâncias entre AB BC CA.</p>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">areaOfTriangle</span><span class="hljs-params">(<span class="hljs-type">float</span> a, <span class="hljs-type">float</span> b, <span class="hljs-type">float</span> c)</span>
</span>{
    <span class="hljs-type">float</span> s = (a + b + c) * <span class="hljs-number">0.5f</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(s*(s-a)*(s-b)*(s-c));
}

<span class="hljs-comment">/* Fórmula básica de área de quadrado.
*/</span>
<span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">areaOfTriangle</span><span class="hljs-params">(<span class="hljs-type">float</span> b, <span class="hljs-type">float</span> h)</span>
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">0.5f</span> * b * h;
}
</code></pre>
<h2 id="distância-entre-dois-pontos">Distância entre dois Pontos</h2>
<p>Fórmula para o cálculo de distância entre dois pontos.</p>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">dist3D</span><span class="hljs-params">(Point a, Point b)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">pow</span>(b.x - a.x, <span class="hljs-number">2</span>)  +  <span class="hljs-built_in">pow</span>(b.y - a.y, <span class="hljs-number">2</span>) + <span class="hljs-built_in">pow</span>(b.z - a.z, <span class="hljs-number">2</span>));
}

<span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">dist2D</span><span class="hljs-params">(Point a, Point b)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">pow</span>(b.x - a.x, <span class="hljs-number">2</span>)  +  <span class="hljs-built_in">pow</span>(b.y - a.y, <span class="hljs-number">2</span>));
}
</code></pre>
<h2 id="produto-vetorial">Produto Vetorial</h2>
<p>O produto vetorial entre os vetores <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> e <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> resulta em um vetor ortogonal (perpendicular) a ambos.
A norma do vetor resultante é: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>a</mi><mi mathvariant="normal">∣</mi><mo>∗</mo><mi mathvariant="normal">∣</mi><mi>b</mi><mi mathvariant="normal">∣</mi><mo>∗</mo><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">|a| * |b| * sin(\alpha)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">a</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">b</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">in</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">)</span></span></span></span>, sendo <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> o ângulo entre os vetores.</p>
<p>Se esse resultado for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>, significa que os vetores são parelelos.</p>
<p>Esse resultado consiste na área do paralelogramo formado pelos vetores (ao dividir por 2, obtém-se a área do triângulo formado pelos vetores)</p>
<pre><code class="language-c++"><span class="hljs-function">Point <span class="hljs-title">cross</span><span class="hljs-params">(Point a, Point b)</span> </span>{
    Point result;
    result.x = a.y * b.z - a.z * b.y;
    result.y = a.z * b.x - a.x * b.z;
    result.z = a.x * b.y - a.y * b.x;

    <span class="hljs-keyword">return</span> result;
}
</code></pre>
<h2 id="produto-escalar">Produto Escalar</h2>
<p>O produto escalar entre os vetores <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> e <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> resulta em: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>a</mi><mi mathvariant="normal">∣</mi><mo>∗</mo><mi mathvariant="normal">∣</mi><mi>b</mi><mi mathvariant="normal">∣</mi><mo>∗</mo><mi>c</mi><mi>o</mi><mi>s</mi><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">|a| * |b| * cos(\alpha)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">a</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">b</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">cos</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">)</span></span></span></span>, sendo <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> o ângulo entre os vetores.</p>
<p>Se o resultado for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>, significa que os vetores são perpendiculares.</p>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">dot</span><span class="hljs-params">(Point a, Point b)</span> </span>{
    <span class="hljs-keyword">return</span> (a.x * b.x) + (a.y * b.y) + (a.z * b.z);
}
</code></pre>
<h2 id="norma">Norma</h2>
<p>A norma nada mais é que o tamanho do vetor. Para obtê-la, basta realizar a raiz quadrada da soma dos quadrados dos componentes.</p>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">norma</span><span class="hljs-params">(Point a)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">dot</span>(a, a));
}
</code></pre>
<h2 id="círculo">Círculo</h2>
<p><strong>THIS CIRCLE HAS BEEN SLICED INTO THE MAXIMUM NUMBER OF SECTIONS
USING 10 SLICES. HOW MANY SECTIONS ARE THERE? HINT: COUNTING SECTIONS
IS TOUGH!. TRY USING THE FORMULA PREVIOUSLY DEVELOPED.</strong></p>
<ul>
<li>
<p>Maximum number of sections of a Circle when sliced by a knife = [n(n+1)/2] +1.<br>
where &quot;n&quot; is the number of slices.</p>
</li>
<li>
<p>A circle has an angle of 2 * PI and an Area of: PI * RAIO^2</p>
</li>
<li>
<p>Area of Sector = (ANG/2) * RAIO^2              (when ANG is in radians)</p>
</li>
<li>
<p>Area of Sector = ((ANG * PI/180)/2) * RAIO^2   (when ANG is in degrees)</p>
</li>
<li>
<p>Arc Length = ANG * RAIO   (when ANG is in radians)</p>
</li>
<li>
<p>Arc Length = ANG * PI/180 * RAIO   (when ANG is in degrees)</p>
</li>
<li>
<p>Area of Segment  = (ANG - sin(ANG))/2 * RAIO^2   (when ANG is in radians)</p>
</li>
<li>
<p>Area of Segment  = (ANG * PI/180 - sin(ANG))/2 * RAIO^2   (when ANG is in degrees)</p>
</li>
</ul>
<h2 id="intersecção-entre-retas-linhas-ou-segmentos-retornando-o-ponto-da-intersecção">Intersecção entre retas (linhas ou segmentos), retornando o ponto da intersecção</h2>
<p>p1 e p2 correspondem ao ponto inicial e final dado de uma linha1</p>
<p>p3 e p4 correspondem ao ponto inicial e final dado de uma linha2</p>
<pre><code class="language-c++"><span class="hljs-function">Point* <span class="hljs-title">intersection</span><span class="hljs-params">(Point p1, Point p2, Point p3, Point p4)</span> </span>{
    <span class="hljs-type">float</span> x1 = p1.x, x2 = p2.x, x3 = p3.x, x4 = p4.x;
    <span class="hljs-type">float</span> y1 = p1.y, y2 = p2.y, y3 = p3.y, y4 = p4.y;

    <span class="hljs-type">float</span> d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

    <span class="hljs-comment">// Se d é zero, não há intersecção.</span>
    <span class="hljs-keyword">if</span> (d == <span class="hljs-number">0</span>)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
    }

    <span class="hljs-comment">// Pega o x e y do ponto de intersecção.</span>
    <span class="hljs-type">float</span> pre = (x1*y2 - y1*x2), post = (x3*y4 - y3*x4);
    <span class="hljs-type">float</span> x = ( pre * (x3 - x4) - (x1 - x2) * post ) / d;
    <span class="hljs-type">float</span> y = ( pre * (y3 - y4) - (y1 - y2) * post ) / d;
    <span class="hljs-comment">/******************************************************************/</span>
    <span class="hljs-comment">// Checa se as coordenadas do ponto então entre os dois segmentos</span>
    <span class="hljs-comment">//OBS: Se for linhas, esse código deve ser comentado, pois essa</span>
    <span class="hljs-comment">//parte do código é apenas quando se lida com SEGMENTOS de reta.</span>
    <span class="hljs-keyword">if</span> ( x &lt; <span class="hljs-built_in">min</span>(x1, x2) || x &gt; <span class="hljs-built_in">max</span>(x1, x2) ||
        x &lt; <span class="hljs-built_in">min</span>(x3, x4) || x &gt; <span class="hljs-built_in">max</span>(x3, x4) ) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">if</span> ( y &lt; <span class="hljs-built_in">min</span>(y1, y2) || y &gt; <span class="hljs-built_in">max</span>(y1, y2) ||
        y &lt; <span class="hljs-built_in">min</span>(y3, y4) || y &gt; <span class="hljs-built_in">max</span>(y3, y4) ) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
    <span class="hljs-comment">/******************************************************************/</span>
    <span class="hljs-comment">// Retorna o ponto da intersecção</span>
    Point* ret = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Point</span>();
    ret-&gt;x = x;
    ret-&gt;y = y;
    <span class="hljs-keyword">return</span> ret;
}
</code></pre>
<h2 id="intersecção-entre-segmentos-de-reta-retornando-booleano">Intersecção entre segmentos de reta (retornando booleano)</h2>
<p>p1 e p2 correspondem ao ponto inicial e final dado de uma linha1</p>
<p>p3 e p4 correspondem ao ponto inicial e final dado de uma linha2</p>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">intersection</span><span class="hljs-params">(Point p1, Point p2, Point p3, Point p4)</span> </span>{
    <span class="hljs-type">float</span> x1 = p1.x, x2 = p2.x, x3 = p3.x, x4 = p4.x;
    <span class="hljs-type">float</span> y1 = p1.y, y2 = p2.y, y3 = p3.y, y4 = p4.y;

    <span class="hljs-type">float</span> d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    <span class="hljs-keyword">if</span> (d == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

    <span class="hljs-type">float</span> pre = (x1*y2 - y1*x2), post = (x3*y4 - y3*x4);
    <span class="hljs-type">float</span> x = ( pre * (x3 - x4) - (x1 - x2) * post ) / d;
    <span class="hljs-type">float</span> y = ( pre * (y3 - y4) - (y1 - y2) * post ) / d;
    <span class="hljs-comment">/******************************************************************/</span>
    <span class="hljs-comment">// Checa se as coordenadas do ponto então entre os dois segmentos</span>
    <span class="hljs-comment">//OBS: Se for linhas, esse código deve ser comentado, pois essa</span>
    <span class="hljs-comment">//parte do código é apenas quando se lida com SEGMENTOS de reta.</span>
    <span class="hljs-keyword">if</span> ( x &lt; <span class="hljs-built_in">min</span>(x1, x2) || x &gt; <span class="hljs-built_in">max</span>(x1, x2) ||
        x &lt; <span class="hljs-built_in">min</span>(x3, x4) || x &gt; <span class="hljs-built_in">max</span>(x3, x4) ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> ( y &lt; <span class="hljs-built_in">min</span>(y1, y2) || y &gt; <span class="hljs-built_in">max</span>(y1, y2) ||
        y &lt; <span class="hljs-built_in">min</span>(y3, y4) || y &gt; <span class="hljs-built_in">max</span>(y3, y4) ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-comment">/******************************************************************/</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
</code></pre>
<h2 id="linhas-coincidentes">Linhas coincidentes</h2>
<p>p1 e p2 correspondem ao ponto inicial e final dado de uma linha1</p>
<p>p3 e p4 correspondem ao ponto inicial e final dado de uma linha2</p>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">linesCoincident</span><span class="hljs-params">(Point p1, Point p2, Point p3, Point p4)</span>
</span>{
    <span class="hljs-type">float</span> nominator_ua = ((p4.x - p3.x)*(p1.y - p3.y)) - ((p4.y - p3.y)*(p1.x - p3.x));
    <span class="hljs-type">float</span> denominator_ua = ((p4.y - p3.y)*(p2.x - p1.x)) - ((p4.x - p3.x)*(p2.y - p1.y));
    <span class="hljs-type">float</span> nominator_ub = ((p2.x - p1.x)*(p1.y - p3.y)) - ((p2.y - p1.y)*(p1.x - p3.x));
    <span class="hljs-type">float</span> denominator_ub = ((p4.y - p3.y)*(p2.x - p1.x)) - ((p4.x - p3.x)*(p2.y - p1.y));
    <span class="hljs-comment">// - Se os nominadores e denominadores para ua e ub forem 0  linhas são coincidentes.</span>
    <span class="hljs-comment">// - se apenas os denominadores forem iguais a zero  as retas são paralelas (essa parte </span>
    <span class="hljs-comment">// não está no código. Se precisa, adicionar depois).</span>
    <span class="hljs-keyword">if</span>(nominator_ua == <span class="hljs-number">0.f</span> &amp;&amp; denominator_ua == <span class="hljs-number">0.f</span>
        &amp;&amp; nominator_ub == <span class="hljs-number">0.f</span> &amp;&amp; denominator_ub == <span class="hljs-number">0.f</span>)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
</code></pre>
<h2 id="testar-linhas-coincidentes-paralelas-e-intersecção-entre-elas">Testar linhas coincidentes, paralelas e intersecção entre elas</h2>
<p>sendo x1 e y1 e x2 e y2 o ponto inicial e final de uma reta</p>
<p>sendo x3 e y3 e x4 e y4 o ponto inicial e final de outra reta</p>
<pre><code class="language-c++"><span class="hljs-type">int</span> x1, y1;
<span class="hljs-type">int</span> x2, y2;
<span class="hljs-type">int</span> x3, y3;
<span class="hljs-type">int</span> x4, y4;
<span class="hljs-type">double</span> m1=<span class="hljs-number">1.0</span>*((x1-x2)*(y3-y4))-((y1-y2)*(x3-x4));
<span class="hljs-type">double</span> m2=<span class="hljs-number">1.0</span>*((x3-x4)*(y3-y1))-((y3-y4)*(x3-x1));
<span class="hljs-type">double</span> m3=<span class="hljs-number">1.0</span>*(-((x3-x1)*(y1-y2))+((y3-y1)*(x1-x2)));
<span class="hljs-comment">/*Caso as linhas sejam coincidentes*/</span>
<span class="hljs-keyword">if</span>(m1==<span class="hljs-number">0</span> &amp;&amp; m2==<span class="hljs-number">0</span> &amp;&amp; m3==<span class="hljs-number">0</span>)
{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Linhas coincidentes.\n&quot;</span>);
}
<span class="hljs-comment">/*Caso as linhas sejam paralelas*/</span>
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(m1==<span class="hljs-number">0</span>)
{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Linhas paralelas\n&quot;</span>);
}
<span class="hljs-comment">/*Se não ocorrer nenhum desses casos
 *então há um ponto x y de intersecção
 *entre as duas linhas.
 */</span>
<span class="hljs-keyword">else</span>
{
    <span class="hljs-type">double</span> intr1=m2/m1;
    <span class="hljs-type">double</span> intr2=m3/m1;
    <span class="hljs-type">double</span> x=x1+intr2*(x2-x1);
    <span class="hljs-type">double</span> y=y1+intr1*(y2-y1);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Ponto de inteseccao: %.2lf %.2lf\n&quot;</span>,x,y);
}
</code></pre>
<h2 id="não-testado-distância-entre-segmentos-de-reta"><strong>(NÃO TESTADO)</strong> Distância entre segmentos de reta</h2>
<pre><code class="language-c++"><span class="hljs-comment">/* SMALL_NUM = ?
* a1 e a2 é uma reta
* b1 e b2 é a outra reta
*/</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SMALL_NUM 0.01f</span>
<span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">distanceSegmentToSegment</span><span class="hljs-params">(Point a1, Point a2, Point b1, Point b2)</span> </span>{
    Point u,v,w;
    u = a2 - a1;
    v = b2 - b1;
    w = a1 - b1;

    <span class="hljs-type">float</span> a = <span class="hljs-built_in">dot</span>(u,u);
    <span class="hljs-type">float</span> b = <span class="hljs-built_in">dot</span>(u,v);
    <span class="hljs-type">float</span> c = <span class="hljs-built_in">dot</span>(v,v);
    <span class="hljs-type">float</span> d = <span class="hljs-built_in">dot</span>(u,w);
    <span class="hljs-type">float</span> e = <span class="hljs-built_in">dot</span>(v,w);

    <span class="hljs-type">float</span> D = a * c - b * b;

    <span class="hljs-type">float</span> sc, sN, sD = D;
    <span class="hljs-type">float</span> tc, tN, tD = D;

    <span class="hljs-keyword">if</span>(D &lt; SMALL_NUM)	{
        sN = <span class="hljs-number">0</span>;
        sD = <span class="hljs-number">1</span>;
        tN = e;
        tD = c;
    } <span class="hljs-keyword">else</span> {
        sN = (b * e - c * d);
        tN = (a * e - b * d);

        <span class="hljs-keyword">if</span>(sN &lt; <span class="hljs-number">0</span>) {
            sN = <span class="hljs-number">0</span>;
            tN = e;
            tD = c;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sN &gt; sD) {
            sN = sD;
            tN = e + b;
            tD = c;
        }
    }

    <span class="hljs-keyword">if</span> (tN &lt; <span class="hljs-number">0</span>)	{
        tN = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (-d &lt; <span class="hljs-number">0</span>) {
            sN = <span class="hljs-number">0</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (-d &gt; a) {
            sN = sD;
        } <span class="hljs-keyword">else</span> {
            sN = -d;
            sD = a;
        }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tN &gt; tD) {
        tN = tD;
        <span class="hljs-keyword">if</span> ((-d + b) &lt; <span class="hljs-number">0.0</span>) {
            sN = <span class="hljs-number">0</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((-d + b) &gt; a) {
            sN = sD;
        } <span class="hljs-keyword">else</span> {
            sN = (-d + b);
            sD = a;
        }
    }

    sc = (<span class="hljs-built_in">abs</span>(sN) &lt; SMALL_NUM ? <span class="hljs-number">0</span> : sN/sD );
    tc = (<span class="hljs-built_in">abs</span>(tN) &lt; SMALL_NUM ? <span class="hljs-number">0</span> : tN/tD );

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">norma</span>(w + u * sc - v * tc);
}
</code></pre>
<h2 id="distância-ponto-a-linha">Distância Ponto a Linha</h2>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">distPointToLine</span><span class="hljs-params">(Point c, Point p1, Point p2)</span> </span>{
   Point pV;
   pV = p2 - p1;

   Point pW;
   pW = c - p1;

   <span class="hljs-type">float</span> c1 = <span class="hljs-built_in">dot</span>(pW, pV);
   <span class="hljs-type">float</span> c2 = <span class="hljs-built_in">dot</span>(pV, pV);
   <span class="hljs-type">float</span> b = c1 / c2;

   Point proj;
   proj = p1 + pV * b;

   <span class="hljs-keyword">return</span> <span class="hljs-built_in">dist</span>(c, proj);
}
</code></pre>
<h2 id="não-testado-distância-ponto-a-segmento-de-reta"><strong>(NÃO TESTADO)</strong> Distância Ponto a Segmento de Reta</h2>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">distPointToSegment</span><span class="hljs-params">(Point c, Point p1, Point p2)</span> </span>{
   Point pV;
   pV = p2 - p1;

   Point pW;
   pW = c - p1;

   <span class="hljs-type">float</span> c1 = <span class="hljs-built_in">dot</span>(pW, pV);
   <span class="hljs-keyword">if</span>(c1 &lt;= <span class="hljs-number">0</span>)
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">dist</span>(c, p1);

   <span class="hljs-type">float</span> c2 = <span class="hljs-built_in">dot</span>(pV, pV);
   <span class="hljs-keyword">if</span>(c2 &lt;= c1)
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">dist</span>(c, p2);

   <span class="hljs-type">float</span> b = c1 / c2;

   Point proj;
   proj = p1 +  pV * b;

   <span class="hljs-keyword">return</span> <span class="hljs-built_in">dist</span>(c, proj);
}
</code></pre>
<h2 id="não-testado-projeção-de-um-ponto-em-um-plano"><strong>(NÃO TESTADO)</strong> Projeção de um Ponto em um Plano</h2>
<p>projeçao do ponto thePoint no plano ABC</p>
<pre><code class="language-c++"><span class="hljs-function">Point <span class="hljs-title">projectionInPlane</span><span class="hljs-params">(Point thePoint, Point a, Point b, Point c)</span> </span>{
    Point normal, p1p2, p1p3, p1p0;
    p1p2 = b - a;
    p1p3 = c - a;
    p1p0 = thePoint - a;
    normal = <span class="hljs-built_in">cross</span>(p1p2, p1p3);

    <span class="hljs-type">float</span> sb, sn, sd;

    sn = -<span class="hljs-built_in">dot</span>(normal, p1p0);
    sd =  <span class="hljs-built_in">dot</span>(normal, normal);

    sb = sn / sd;

    <span class="hljs-keyword">return</span> thePoint + normal * sb;
}

<span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">distPointToPlane</span><span class="hljs-params">(Point thePoint, Point a,Point b, Point c)</span> </span>{   
	<span class="hljs-keyword">return</span> <span class="hljs-built_in">dist</span>(thePoint, <span class="hljs-built_in">projectionInPlane</span>(thePoint, a, b, c));
}
</code></pre>
<h2 id="não-testado-ponto-dentro-de-polígonos"><strong>(NÃO TESTADO)</strong> Ponto dentro de Polígonos</h2>
<p>Testa se ponto está dentro de um poligono pelo numero de vezes q ele passa por arestas verticalmente, funciona somente em 2D</p>
<p>V[] = vertex points of a polygon V[n+1] with V[n]=V[0]</p>
<p>Return:  0 = outside, 1 = inside</p>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">crossingNumbers</span><span class="hljs-params">(Point P, vector&lt;Point&gt; V)</span> </span>{ <span class="hljs-comment">// 2D</span>
   <span class="hljs-type">int</span> cn = <span class="hljs-number">0</span>;
   <span class="hljs-type">float</span> vt;
   <span class="hljs-type">float</span> next;

   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V.<span class="hljs-built_in">size</span>(); i++) {
      next = i + <span class="hljs-number">1</span>;

      <span class="hljs-keyword">if</span>(next == V.<span class="hljs-built_in">size</span>()) next = <span class="hljs-number">0</span>;
         
      <span class="hljs-keyword">if</span>(((V[i].y &lt;= P.y) &amp;&amp; (V[next].y &gt; P.y)) || 
         ((V[i].y &gt; P.y) &amp;&amp; (V[next].y &lt;= P.y))) {
         vt = (<span class="hljs-type">float</span>)(P.y - V[i].y) / (V[next].y - V[i].y);

         <span class="hljs-keyword">if</span> (P.x &lt; V[i].x + vt * (V[next].x - V[i].x))
            ++cn;
      }
   }
   <span class="hljs-keyword">return</span> (cn % <span class="hljs-number">2</span>);
}
</code></pre>
<h2 id="não-testado-sweep-line">(NÃO TESTADO) Sweep Line</h2>
<pre><code class="language-c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
 
<span class="hljs-comment">// A point in 2D plane</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>
{
    <span class="hljs-type">int</span> x, y;
};
 
<span class="hljs-comment">// A line segment with left as Point</span>
<span class="hljs-comment">// with smaller x value and right with</span>
<span class="hljs-comment">// larger x value.</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Segment</span>
{
    Point left, right;
};
 
 
<span class="hljs-comment">// An event for sweep line algorithm</span>
<span class="hljs-comment">// An event has a point, the position</span>
<span class="hljs-comment">// of point (whether left or right) and</span>
<span class="hljs-comment">// index of point in the original input</span>
<span class="hljs-comment">// array of segments.</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Event</span> {
    <span class="hljs-type">int</span> x, y;
    <span class="hljs-type">bool</span> isLeft;
    <span class="hljs-type">int</span> index;
    <span class="hljs-built_in">Event</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">bool</span> l, <span class="hljs-type">int</span> i) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y), <span class="hljs-built_in">isLeft</span>(l), <span class="hljs-built_in">index</span>(i) {}
 
    <span class="hljs-comment">// This is for maintaining the order in set.</span>
    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Event&amp; e) <span class="hljs-type">const</span> {
            <span class="hljs-keyword">if</span>(y==e.y)<span class="hljs-keyword">return</span> x&lt;e.x;
            <span class="hljs-keyword">return</span> y &lt; e.y;
    }
};
 
 
<span class="hljs-comment">// Given three collinear points p, q, r, the function checks if</span>
<span class="hljs-comment">// point q lies on line segment &#x27;pr&#x27;</span>
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">onSegment</span><span class="hljs-params">(Point p, Point q, Point r)</span>
</span>{
    <span class="hljs-keyword">if</span> (q.x &lt;= <span class="hljs-built_in">max</span>(p.x, r.x) &amp;&amp; q.x &gt;= <span class="hljs-built_in">min</span>(p.x, r.x) &amp;&amp;
        q.y &lt;= <span class="hljs-built_in">max</span>(p.y, r.y) &amp;&amp; q.y &gt;= <span class="hljs-built_in">min</span>(p.y, r.y))
       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
 
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
 
<span class="hljs-comment">// To find orientation of ordered triplet (p, q, r).</span>
<span class="hljs-comment">// The function returns following values</span>
<span class="hljs-comment">// 0 --&gt; p, q and r are collinear</span>
<span class="hljs-comment">// 1 --&gt; Clockwise</span>
<span class="hljs-comment">// 2 --&gt; Counterclockwise</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">orientation</span><span class="hljs-params">(Point p, Point q, Point r)</span>
</span>{
    <span class="hljs-comment">// See https://www.geeksforgeeks.org/orientation-3-ordered-points/</span>
    <span class="hljs-comment">// for details of below formula.</span>
    <span class="hljs-type">int</span> val = (q.y - p.y) * (r.x - q.x) -
              (q.x - p.x) * (r.y - q.y);
 
    <span class="hljs-keyword">if</span> (val == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// collinear</span>
 
    <span class="hljs-keyword">return</span> (val &gt; <span class="hljs-number">0</span>)? <span class="hljs-number">1</span>: <span class="hljs-number">2</span>; <span class="hljs-comment">// clock or counterclock wise</span>
}
 
<span class="hljs-comment">// The main function that returns true if line segment &#x27;p1q1&#x27;</span>
<span class="hljs-comment">// and &#x27;p2q2&#x27; intersect.</span>
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">doIntersect</span><span class="hljs-params">(Segment s1, Segment s2)</span>
</span>{
    Point p1 = s1.left, q1 = s1.right, p2 = s2.left, q2 = s2.right;
 
    <span class="hljs-comment">// Find the four orientations needed for general and</span>
    <span class="hljs-comment">// special cases</span>
    <span class="hljs-type">int</span> o1 = <span class="hljs-built_in">orientation</span>(p1, q1, p2);
    <span class="hljs-type">int</span> o2 = <span class="hljs-built_in">orientation</span>(p1, q1, q2);
    <span class="hljs-type">int</span> o3 = <span class="hljs-built_in">orientation</span>(p2, q2, p1);
    <span class="hljs-type">int</span> o4 = <span class="hljs-built_in">orientation</span>(p2, q2, q1);
 
    <span class="hljs-comment">// General case</span>
    <span class="hljs-keyword">if</span> (o1 != o2 &amp;&amp; o3 != o4)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
 
    <span class="hljs-comment">// Special Cases</span>
    <span class="hljs-comment">// p1, q1 and p2 are collinear and p2 lies on segment p1q1</span>
    <span class="hljs-keyword">if</span> (o1 == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">onSegment</span>(p1, p2, q1)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
 
    <span class="hljs-comment">// p1, q1 and q2 are collinear and q2 lies on segment p1q1</span>
    <span class="hljs-keyword">if</span> (o2 == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">onSegment</span>(p1, q2, q1)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
 
    <span class="hljs-comment">// p2, q2 and p1 are collinear and p1 lies on segment p2q2</span>
    <span class="hljs-keyword">if</span> (o3 == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">onSegment</span>(p2, p1, q2)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
 
     <span class="hljs-comment">// p2, q2 and q1 are collinear and q1 lies on segment p2q2</span>
    <span class="hljs-keyword">if</span> (o4 == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">onSegment</span>(p2, q1, q2)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
 
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Doesn&#x27;t fall in any of the above cases</span>
}
 
 
<span class="hljs-comment">// Find predecessor of iterator in s.</span>
 set&lt;Event&gt;::<span class="hljs-function">iterator <span class="hljs-title">pred</span><span class="hljs-params">(set&lt;Event&gt; &amp;s, set&lt;Event&gt;::iterator it)</span> </span>{
    <span class="hljs-keyword">return</span> it == s.<span class="hljs-built_in">begin</span>() ? s.<span class="hljs-built_in">end</span>() : --it;
}
 
<span class="hljs-comment">// Find successor of iterator in s.</span>
set&lt;Event&gt;::<span class="hljs-function">iterator <span class="hljs-title">succ</span><span class="hljs-params">(set&lt;Event&gt; &amp;s, set&lt;Event&gt;::iterator it)</span> </span>{
    <span class="hljs-keyword">return</span> ++it;
}
 
<span class="hljs-comment">// Returns true if any two lines intersect.</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">isIntersect</span><span class="hljs-params">(Segment arr[], <span class="hljs-type">int</span> n)</span>
</span>{
    unordered_map&lt;string,<span class="hljs-type">int</span>&gt; mp;  <span class="hljs-comment">// to note the pair for which intersection is checked already</span>
    <span class="hljs-comment">// Pushing all points to a vector of events</span>
    vector&lt;Event&gt; e;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {
        e.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Event</span>(arr[i].left.x, arr[i].left.y, <span class="hljs-literal">true</span>, i));
        e.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Event</span>(arr[i].right.x, arr[i].right.y, <span class="hljs-literal">false</span>, i));
    }
 
    <span class="hljs-comment">// Sorting all events according to x coordinate.</span>
    <span class="hljs-built_in">sort</span>(e.<span class="hljs-built_in">begin</span>(), e.<span class="hljs-built_in">end</span>(), [](Event &amp;e1, Event &amp;e2) {<span class="hljs-keyword">return</span> e1.x &lt; e2.x;});
 
    <span class="hljs-comment">// For storing active segments.</span>
    set&lt;Event&gt; s;
     <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;
    <span class="hljs-comment">// Traversing through sorted points</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">2</span>*n; i++)
    {
        Event curr = e[i];
        <span class="hljs-type">int</span> index = curr.index;
 
        <span class="hljs-comment">// If current point is left of its segment</span>
        <span class="hljs-keyword">if</span> (curr.isLeft)
        {
            <span class="hljs-comment">// Get above and below points</span>
            <span class="hljs-keyword">auto</span> next = s.<span class="hljs-built_in">lower_bound</span>(curr);
            <span class="hljs-keyword">auto</span> prev = <span class="hljs-built_in">pred</span>(s, next);
            <span class="hljs-comment">// Check if current point intersects with</span>
            <span class="hljs-comment">// any of its adjacent</span>
            <span class="hljs-type">bool</span> flag=<span class="hljs-literal">false</span>;
            <span class="hljs-keyword">if</span> (next != s.<span class="hljs-built_in">end</span>() &amp;&amp; <span class="hljs-built_in">doIntersect</span>(arr[next-&gt;index], arr[index])){
                string s=<span class="hljs-built_in">to_string</span>(next-&gt;index+<span class="hljs-number">1</span>)+<span class="hljs-string">&quot; &quot;</span>+<span class="hljs-built_in">to_string</span>(index+<span class="hljs-number">1</span>);
                <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(s)==<span class="hljs-number">0</span>){mp[s]++;ans++;} <span class="hljs-comment">//if not already checked we can increase count in map</span>
            }
            <span class="hljs-keyword">if</span> (prev != s.<span class="hljs-built_in">end</span>() &amp;&amp; <span class="hljs-built_in">doIntersect</span>(arr[prev-&gt;index], arr[index])){
                    string s=<span class="hljs-built_in">to_string</span>(prev-&gt;index+<span class="hljs-number">1</span>)+<span class="hljs-string">&quot; &quot;</span>+<span class="hljs-built_in">to_string</span>(index+<span class="hljs-number">1</span>);
                <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(s)==<span class="hljs-number">0</span>){mp[s]++;ans++;} <span class="hljs-comment">//if not already checked we can increase count in map</span>
            }
            <span class="hljs-comment">// if same line segment is there then decrease answer as it got increased twice</span>
            <span class="hljs-keyword">if</span>(prev != s.<span class="hljs-built_in">end</span>() &amp;&amp; next != s.<span class="hljs-built_in">end</span>() &amp;&amp; next-&gt;index==prev-&gt;index)ans--;
 
 
            <span class="hljs-comment">// Insert current point (or event)</span>
            s.<span class="hljs-built_in">insert</span>(curr);
        }
 
        <span class="hljs-comment">// If current point is right of its segment</span>
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-comment">// Find the iterator</span>
            <span class="hljs-keyword">auto</span> it=s.<span class="hljs-built_in">find</span>(<span class="hljs-built_in">Event</span>(arr[index].left.x, arr[index].left.y, <span class="hljs-literal">true</span>, index));
            <span class="hljs-comment">// Find above and below points</span>
            <span class="hljs-keyword">auto</span> next = <span class="hljs-built_in">succ</span>(s, it);
            <span class="hljs-keyword">auto</span> prev = <span class="hljs-built_in">pred</span>(s, it);
 
            <span class="hljs-comment">// If above and below point intersect</span>
            <span class="hljs-keyword">if</span> (next != s.<span class="hljs-built_in">end</span>() &amp;&amp; prev != s.<span class="hljs-built_in">end</span>())
               {  string s=<span class="hljs-built_in">to_string</span>(next-&gt;index+<span class="hljs-number">1</span>)+<span class="hljs-string">&quot; &quot;</span>+<span class="hljs-built_in">to_string</span>(prev-&gt;index+<span class="hljs-number">1</span>);
                    string s1=<span class="hljs-built_in">to_string</span>(prev-&gt;index+<span class="hljs-number">1</span>)+<span class="hljs-string">&quot; &quot;</span>+<span class="hljs-built_in">to_string</span>(next-&gt;index+<span class="hljs-number">1</span>);
                   <span class="hljs-keyword">if</span> (mp.<span class="hljs-built_in">count</span>(s)==<span class="hljs-number">0</span>&amp;&amp;mp.<span class="hljs-built_in">count</span>(s1)==<span class="hljs-number">0</span>&amp;&amp;<span class="hljs-built_in">doIntersect</span>(arr[prev-&gt;index], arr[next-&gt;index]))
                    ans++;
                    mp[s]++;
                  }
 
            <span class="hljs-comment">// Remove current segment</span>
            s.<span class="hljs-built_in">erase</span>(it);
 
        }
    }
    <span class="hljs-comment">//print pair of lines having intersection</span>
 
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;pr:mp){
        cout&lt;&lt;<span class="hljs-string">&quot;Line: &quot;</span>&lt;&lt;pr.first&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;
    }
    <span class="hljs-keyword">return</span> ans;
}
 
<span class="hljs-comment">// Driver code</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Segment arr[] = { {{<span class="hljs-number">1</span>, <span class="hljs-number">5</span>}, {<span class="hljs-number">4</span>, <span class="hljs-number">5</span>}}, {{<span class="hljs-number">2</span>, <span class="hljs-number">5</span>}, {<span class="hljs-number">10</span>, <span class="hljs-number">1</span>}},{{<span class="hljs-number">3</span>, <span class="hljs-number">2</span>}, {<span class="hljs-number">10</span>, <span class="hljs-number">3</span>}},{{<span class="hljs-number">6</span>, <span class="hljs-number">4</span>}, {<span class="hljs-number">9</span>, <span class="hljs-number">4</span>}},{{<span class="hljs-number">7</span>, <span class="hljs-number">1</span>}, {<span class="hljs-number">8</span>, <span class="hljs-number">1</span>}}};
    <span class="hljs-type">int</span> n = <span class="hljs-built_in">sizeof</span>(arr)/<span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">0</span>]);
    cout&lt;&lt;<span class="hljs-string">&quot;Number of intersection points: &quot;</span>&lt;&lt;<span class="hljs-built_in">isIntersect</span>(arr, n);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

        <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </body>
    </html>